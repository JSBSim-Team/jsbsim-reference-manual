{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"JSBSim Reference Manual","text":"<p>JSBSim is a lightweight, data-driven, non-linear, six-degree-of-freedom (6DoF), batch simulation application aimed at modeling flight dynamics and control for aircraft. Since the earliest versions, JSBSim has benefited from the open source development environment it has grown within and from the wide variety of users that have contributed ideas for its continued improvement.</p> <p>This online reference manual is a community effort to keep the users and developers up-to-date with all the functionalities of the software.</p> <p>Licensing: JSBSim is licensed under the terms of the GNU Lesser GPL (LGPL).</p>"},{"location":"#useful-links","title":"Useful Links","text":"<ul> <li>JSBSim Website</li> <li>JSBSim Projects on GitHub</li> </ul>"},{"location":"acknowledgements/","title":"Acknowledgements","text":"<p>This software is the result of work done by many people over the years.</p> <p>Tony Peden has been contributing to the growth of JSBSim almost from day 1. He is responsible for the initialization and trimming code. Tony also incorporated David Megginson's property system into JSBSim. Tony hails from Ohio State University, with a degree in Aero and Astronautical Engineering.</p> <p>David Culp developed the turbine model for JSBSim, and crafted several aircraft models that use it including the T-38. David has experience flying many types of military and commercial aircraft, including the T-38, and the Boeing 707, 727, 737, 757, 767, the SGS 2-32, and the OV-10. David is an aerospace engineer, a graduate from the U.S. Air Force Academy.</p> <p>David Megginson came from a long involvement as a core FlightGear developer. David correlated our flight dynamics with his general aviation flying experience to aid in maximum realism, among other things. David designed the property system that both FlightGear and JSBSim use. He is well known for his contributions to XML technology, and wrote the easyXML parser that both FlightGear and JSBSim use.</p> <p>Erik Hofman has done a bit of everything, hunting down aircraft data, creating flight models (F-16), and performing some programming. He also tests for IRIX compatibility. Erik has a degree in Computer Science.</p> <p>Mathias Fr\u00f6lich added a versatile per-gear ground elevation capability, and many other things. Mathias is a mathematician from Germany.</p> <p>Agostino De Marco has created a broadly capable cost/penalty trim analysis feature for JSBSim, and has used JSBSim by itself and together with FlightGear at the University of Naples.</p> <p>David Luff from the United Kingdom provided the original piston engine model. Ron Jensen has steadily refined it.</p> <p>Engineers with many years of simulation experience, Lee Duke and Bill Galbraith have contributed suggestions and ideas that have improved JSBSim.</p> <p>Bruce Jackson from NASA Langley Research Center \u2013 who has been involved in the development and use of a variety of simulations for many years \u2013 has been supportive and helpful, and the simulation code he wrote in C many years ago, (\u201cLaRCSim\u201d) was instructive in the early development of JSBSim.</p> <p>Curt Olson, who coordinates the development of FlightGear and some of its constituent parts (SimGear) has been a great help over the years in countless discussions of simulation, control theory, and many other topics. Working with the FlightGear community has made JSBSim a better tool.</p> <p>Finally, the user and developer community has worked well to bring JSBSim to where it is today. Thanks are due to anyone who has ever taken the time to report a bug or to ask for a feature.</p>","tags":["about"]},{"location":"contact/","title":"Contact","text":"<p>Agostino De Marco, PhD</p> <p>Assistant Professor of Flight Mechanics</p> <p>Universit\u00e0 degli Studi di Napoli Federico II, Department Industrial Engineering</p> <p>DAF \u2014 Design of Aircraft and Flight technologies research group</p> <p>via Claudio 21, 80125 Napoli - Italy</p> <p>Tel.: +39 0817683323</p> <p>Email: agostino dot demarco at unina dot it</p> <p>Web 0: www.docenti.unina.it - agostino.de_marco</p> <p>Web 1: www.dii.unina.it</p> <p>Web 2: www.daf.unina.it</p>","tags":["menu","contact"]},{"location":"licensing/","title":"Licensing","text":"","tags":["menu","contributing"]},{"location":"licensing/#information-for-text-contributors","title":"Information for text contributors","text":"<p>To grow the commons of free knowledge and free culture, all users contributing to this JSBSim reference manual are required to grant broad permissions to the general public to re-distribute and re-use their contributions freely, as long as the use is attributed and the same freedom to re-use and re-distribute applies to any derivative works. Therefore, for any text you hold the copyright to, by submitting it, you agree to license it under the GNU Lesser GPL (LGPL).</p>","tags":["menu","contributing"]},{"location":"licensing/#information-for-non-text-media-contributors","title":"Information for non-text media contributors","text":"<p>Non-text media on the FlightGear wiki are available under a variety of different licenses. Where not specified, non-text media are licensed under Creative Commons.</p>","tags":["menu","contributing"]},{"location":"preface/","title":"Preface","text":"<p>JSBSim was conceived in 1996 as a lightweight, data-driven, non-linear, six-degree-of-freedom (6DoF), batch simulation application aimed at modeling flight dynamics and control for aircraft. Since the earliest versions, JSBSim has benefited from the open source development environment it has grown within and from the wide variety of users that have contributed ideas for its continued improvement.</p>","tags":["menu","about","preface"]},{"location":"preface/#about-this-manual","title":"About this Manual","text":"<p>This online document is split up into several parts. This is because JSBSim can be viewed from several different perspectives: from that of a flight vehicle model developer, from that of an integrator who will incorporate JSBSim into a full flight simulation architecture with visuals, and from that of a software developer who wants to adapt or enhance JSBSim with additional capabilities.</p> <p>There is a QuickStart part, a Section Zero, that explains how to get started with JSBSim quickly.</p> <p>The following by Section One is a User's Manual, that explains how to use JSBSim to make simulation runs, to create aircraft models, to write scripts, and how to perform various other tasks that do not involve changes to program code in JSBSim itself.</p> <p>Section Two is a Programmer's Manual, that explains the architecture of JSBSim \u2014 how the code is organized and how it works.</p> <p>Section Three is the Formulation Manual, which contains a description of the math model and algorithms present in JSBSim.</p> <p>Section Four is a collection of some examples and case studies showing how JSBSim has been used.</p>","tags":["menu","about","preface"]},{"location":"preface/#what-this-document-is-not","title":"What this document is not","text":"<p>This document is not an exhaustive reference on the derivation of the equations of motion and flight dynamics. For a text on that, see (Stevens:Lewis:Johnson:2015), and (Zipfel:2003). Yet, this document is meant to be the authoritative document about JSBSim.</p>","tags":["menu","about","preface"]},{"location":"references/","title":"References","text":"<ol> <li> <p>Stevens, B. L., Lewis, F. L., Johnson, E. N.,    Aircraft Control and Simulation: Dynamics, Controls Design, and Autonomous Systems,     John Wiley &amp; Sons, 2015.     (Stevens:Lewis:Johnson:2015)</p> </li> <li> <p>Zipfel, P. H.,    Modeling and Simulation of Aerospace Vehicle Dynamics,    AIAA (American Institute of Aeronautics and Astronautics), Education Series, 2003.    (Zipfel:2003)</p> </li> <li> <p>Zipfel, P. H.,    Building Aerospace Simulations in C++: Multimedia Training in 16 Labs,     AIAA (American Institute of Aeronautics and Astronautics), 2008.     (Zipfel:2008)</p> </li> <li> <p>Filippone, A.,     Flight Performance of Fixed and Rotary Wing Aircraft,     American Institute of Aeronautics and Astronautics, AIAA Educational Series, 2006,     ISBN 978-1-5634-7839-0. (Filippone:2006)</p> </li> <li> <p>Torenbeek, E., Wittenberg, H.,     Flight Physics. Essentials of Aeronautical Disciplines and Technology, with Historical Notes,     Springer, 2009,     ISBN 978-1-4020-8663-2, DOI 10.1007/978-1-4020-8664-9,     (Torenbeek:Wittenberg:2009)</p> </li> </ol>","tags":["menu"]},{"location":"formulation/","title":"Formulation manual","text":"<p>TBD</p>"},{"location":"formulation/earth-modeling/","title":"Earth Modelling","text":"<p>TBD</p>"},{"location":"formulation/earth-modeling/#longitude-definitions","title":"Longitude Definitions","text":"<p>TBD</p>"},{"location":"formulation/earth-modeling/#geocentric-coordinates-of-a-point","title":"Geocentric Coordinates of a Point","text":"<p>TBD</p>"},{"location":"formulation/earth-modeling/#geodetic-coordinates-of-a-point","title":"Geodetic Coordinates of a Point","text":"<p>TBD</p>"},{"location":"formulation/earth-modeling/#radii-of-curvature","title":"Radii of Curvature","text":"<p>TBD</p>"},{"location":"formulation/earth-modeling/#trigonometric-relationships-for-the-spheroid","title":"Trigonometric Relationships for the Spheroid","text":"<p>TBD</p>"},{"location":"formulation/earth-modeling/#cartesianpolar-coordinate-conversions","title":"Cartesian/Polar Coordinate Conversions","text":"<p>TBD</p>"},{"location":"formulation/earth-modeling/#earth-related-coordinate-transformations","title":"Earth-Related Coordinate Transformations","text":"<p>TBD</p> <p>The dry air adiabatic lapse rate (DALR) is 3\u00a0\u00b0C per 1000\u00a0ft (304.8\u00a0m), or 1\u00a0\u00b0C per 100\u00a0m. The saturated-air adiabatic lapse rate (SALR) is 1.5\u00a0\u00b0C per 1000\u00a0ft or 0.5\u00a0\u00b0C per 100\u00a0m. Therefore, \\(\\lambda_\\mathrm{SALR} = \\frac{1}{2} \\lambda_\\mathrm{DALR}\\).</p> <p>The rate of change of temperature with height \\(h\\) in the atmospheric layers at a place and time is called its temperature lapse rate or simply lapse rate, which is denoted by \\(\\lambda\\). The lapse rate is considered positive if the temperature decreases with height, and vice versa.</p> \\[ \\begin{equation} \\lambda = - \\frac{\\mathrm{d}T}{\\mathrm{d}h} \\label{eq:Lapse:Rate} \\end{equation} \\]"},{"location":"formulation/equations-of-motion-ii/","title":"Equations of motion","text":"<p>The core purpose of a flight dynamics model is to propagate and track the path of a flying craft over the surface of the Earth (or another planet), given the forces and moments that act on the vehicle. We know the characteristics of the aircraft, and we know the characteristics of the planet (gravity, rotation rate, etc.). And it is expected that the reader is familiar with rigid body dynamics, where moving reference frames are involved. Still, putting all of the pieces together in a flight simulator can be overwhelming and tedious.</p> <p>This section discusses aerospace vehicle equations of motion, as implemented in <code>JSBSim::FGPropagate</code>, using the quaternion, matrix, vector, and location math classes provided in JSBSim. Many of the equations listed in the following sections related to the rigid body equations of motion are taken from the book (Stevens:Lewis:Johnson:2015), which is considered the main formulation reference for the JSBSim software.</p> <p>The notation used in this reference manual is the same that Stevens and Lewis use:</p> <ul> <li> <p>The lower right subscript, e.g. \\(\\boldsymbol{v}_\\mathrm{CM/e}\\), describes the object or frame relationship of the parameter.   In the example given, \\(\\boldsymbol{v}_\\mathrm{CM/e}\\), we refer to the velocity of the CM (center of mass) with respect to the ECEF frame.</p> </li> <li> <p>The upper right superscript, e.g. \\(\\boldsymbol{v}^\\mathrm{b}\\), refers to a coordinate system.   That is, it states which coordinate system the motion is expressed in.</p> </li> <li> <p>The left superscript specifies the frame in which a derivative is taken.</p> </li> </ul> <p>To be completed</p> <p> </p>      Earth-Centered Inertial (ECI) frame and Earth-Centered Earth-Fixed (ECEF) frame.    <p> </p>      Earth-Centered Earth-Fixed (ECEF) frame, geografic coordinates, Tangent (T) frame, and local Vertical (V) frame.    <p> </p> <p>     Aircraft angular velocity vector \\(\\boldsymbol{\\Omega}\\) and angular speed componeents in body axes \\((p,q,r)\\).   </p> <p> </p> <p>     Ground reaction model. A situation of ground contact with \\(\\mathrm{WOW} = 1\\) for the right wheel of the main gear and \\(\\mathrm{WOW} = 0\\) for the nose wheel.   </p>"},{"location":"formulation/equations-of-motion/","title":"Equations of motion","text":"<p>The core purpose of a flight dynamics model is to propagate and track the path of a flying craft over the surface of the Earth (or another planet), given the forces and moments that act on the vehicle. We know the characteristics of the aircraft, and we know the characteristics of the planet (gravity, rotation rate, etc.). And it is expected that the reader is familiar with rigid body dynamics, where moving reference frames are involved. Still, putting all of the pieces together in a flight simulator can be overwhelming and tedious.</p> <p>This section discusses aerospace vehicle equations of motion, as implemented in <code>JSBSim::FGPropagate</code>, using the quaternion, matrix, vector, and location math classes provided in JSBSim. Many of the equations listed in the following sections related to the rigid body equations of motion are taken from the book (Stevens:Lewis:Johnson:2015), which is considered the main formulation reference for the JSBSim software.</p> <p>The notation used in this reference manual is the same that Stevens and Lewis use:</p> <ul> <li> <p>The lower right subscript, e.g. \\(\\boldsymbol{v}_\\mathrm{CM/e}\\), describes the object or frame relationship of the parameter.   In the example given, \\(\\boldsymbol{v}_\\mathrm{CM/e}\\), we refer to the velocity of the CM (center of mass) with respect to the ECEF frame.</p> </li> <li> <p>The upper right superscript, e.g. \\(\\boldsymbol{v}^\\mathrm{b}\\), refers to a coordinate system.   That is, it states which coordinate system the motion is expressed in.</p> </li> <li> <p>The left superscript specifies the frame in which a derivative is taken.</p> </li> </ul> <p>To be completed</p> <p> </p>      Earth-Centered Inertial (ECI) frame and Earth-Centered Earth-Fixed (ECEF) frame.    <p> </p>      Earth-Centered Earth-Fixed (ECEF) frame, geografic coordinates, Tangent (T) frame, and local Vertical (V) frame.    <p> </p> <p>     Aircraft angular velocity vector \\(\\boldsymbol{\\Omega}\\) and angular speed componeents in body axes \\((p,q,r)\\).   </p> <p> </p> <p>     Ground reaction model. A situation of ground contact with \\(\\mathrm{WOW} = 1\\) for the right wheel of the main gear and \\(\\mathrm{WOW} = 0\\) for the nose wheel.   </p>"},{"location":"formulation/overview/","title":"Overview","text":"<p>The equations of motion of a flying vehicle can be organized as a set of simultaneous first-order differential equations, explicitly solved for the derivatives. For \\(n\\) independent variables, \\(x_i\\) (such as components of position, velocity, etc.), and \\(m\\) control inputs, \\(u_i\\) (such as throttle, control surface deflection, etc.), the general form will be</p> \\[ \\left\\{   \\begin{array}{rl}     \\dot{x}_1 &amp; {}= f_1\\big( x_1\\,,\\, x_2\\,,\\, \\ldots \\,,\\,x_n\\,,\\,u_1\\,,\\, u_2\\,,\\, \\ldots \\,,\\,u_m \\big) \\\\     \\dot{x}_2 &amp; {}= f_2\\big( x_1\\,,\\, x_2\\,,\\, \\ldots \\,,\\,x_n\\,,\\,u_1\\,,\\, u_2\\,,\\, \\ldots \\,,\\,u_m \\big) \\\\       \\cdots  &amp; \\quad \\cdots \\\\     \\dot{x}_n &amp; {}= f_n\\big( x_1\\,,\\, x_2\\,,\\, \\ldots \\,,\\,x_n\\,,\\,u_1\\,,\\, u_2\\,,\\, \\ldots \\,,\\,u_m \\big)   \\end{array} \\right. \\label{eq:EoM:ODE} \\] <p>where the functions \\(f_i\\) are the nonlinear functions that arise from modeling vehicle's real subsystems. The variables \\(x:i\\) constitute the smallest set of variables that, together with given inputs \\(u_i\\), completely describe the behavior of the system (i.e. allow to deterministically compute its evolution in time), and called the set of state variables for the system, and Equations (\\(\\ref{eq:EoM:ODE}\\)) are a state-space description of the system. The functions \\(f_i\\) are single-valued continuous functions. Equations (\\(\\ref{eq:EoM:ODE}\\)) are often written symbolically as</p> \\[ \\dot{\\boldsymbol{x}} = \\boldsymbol{f}\\big( \\boldsymbol{x}\\,,\\,\\boldsymbol{u} \\big) \\label{eq:EoM:ODE:Compact} \\] <p>where the state vector \\(\\boldsymbol{x}\\) is an \\(n \\times 1\\) column array of the \\(n\\) state variables, the control vector \\(\\boldsymbol{u}\\) is an \\(m \\times 1\\) column array of the control variables, and \\(\\boldsymbol{f}\\) is an array of nonlinear functions.</p> <p>When \\(\\boldsymbol{u}\\) is held constant, the nonlinear state equations (\\(\\ref{eq:EoM:ODE}\\)), or a subset of them, usually have one or more equilibrium points in the multidimensional state and control space, where a given set of state variable derivatives vanish (usually derivatives having the meaning of translational or angular accelerations).</p> <p>A major advantage of the state-space formulation is that the nonlinear state equations can be solved numerically. The simplest numerical solution method is Euler integration, described by</p> \\[ \\boldsymbol{x}(t_{k+1}) = \\boldsymbol{x}(t_k) + \\boldsymbol{f}\\big( \\boldsymbol{x}_k\\,,\\,\\boldsymbol{u}_k \\big) \\, \\Delta t \\label{eq:EoM:ODE:Euler:Integration} \\] <p>in which \\(\\boldsymbol{x}(t_k)\\) is the value of the state vector computed at discrete times \\(t_k = k \\Delta t\\), with \\(k = 0,1,2, \\ldots\\), starting from an assigned initial condition \\(\\boldsymbol{x}(t_0) = \\boldsymbol{x}_0\\). The integration time step, \\(\\Delta t\\), must be made small enough that, for every \\(\\Delta t\\) interval, \\(\\boldsymbol{u}\\)  can be approximated by a constant value \\(\\boldsymbol{u}(t_k)\\), and \\(\\dot{\\boldsymbol{x}} \\Delta t\\)  provides a good approximation to the increment in the state vector. This numerical integration allows the state vector to be stepped forward, in time increments of \\(\\Delta t\\), to obtain a time-history simulation.</p> <p>TBD</p>"},{"location":"formulation/quaternions/","title":"Quaternions","text":"<p>TBD</p>"},{"location":"programmer/","title":"Programmer manual","text":"<p>One of the specific goals of the design of JSBSim is to make sure it is relatively easy to incorporate into a small or large simulation program. As often happens with simulation programs (and software applications in general) \"feature creep\" sets in and the program code blossoms into a larger-than-intended product. In the case of JSBSim, we have attempted to maintain the code base as small as possible, but at first glance it can still be overwhelming.</p> <p>Unlike some simulator applications, JSBSim (at the time of this writing) has no external dependencies. That is, all code that is needed to build JSBSim is packaged along with it. This greatly simplifies the building of the JSBSim executable. There is also no automatically generated code within JSBSim. All code is straight C++ (with some C code from the included eXpat XML parsing code).</p> <p>No proprietary program code is included in JSBSim distribution. All code coming with JSBSim has been developed on a volunteer basis using publicly available information, and is often directly referenced to a particular textbook, for educational purposes. In some cases, code of a generic nature has been donated back to the project.</p>"},{"location":"programmer/class-hierarchy/","title":"Class Hierarchy","text":"<p>TODO</p> <p>Complete page content.</p> <pre><code>fdmex = new FGFDMExec( /* ... */ ); // (1) Instantiation\nresult = fdmex-&gt;LoadModel( /* ... */ ); // (2) Model loading\n</code></pre> <p> </p>      Class diagram of class FGJSBBase.    <p> </p>      Call graph of the function FGFDMExec::Initialize."},{"location":"programmer/overview/","title":"Overview","text":"<p>What does the JSBSim source code consist of?</p> <p>TODO</p> <p>Complete page contents.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>To use JSBSim productively you might want to assume a programmer's attitude. This means you will have to download the sources yourself and compile them on your platform. With the right set of tools installed on your computer, this is a painless procedure after all.</p> <p>For the impatients, there are automatic remote build procedures that deliver up-to-date binaries of the library. These can be found on the following links:</p>","tags":["quickstart"]},{"location":"quickstart/#builds-provided-by-the-flightgear-project-developers-jenkins-server","title":"Builds provided by the FlightGear project developers (Jenkins server)","text":"<ul> <li>JSBSim build for Linux (Linux CentOS 7 VM)</li> </ul> <p>Go to the workspace area build.flightgear.org:8080/job/JSBSim/ws and download all files as a Zip archive. Explore the archive, go to the folder <code>/JSBSim/build/src/</code>, and find: the executable file <code>JSBSim</code> and the static library file <code>libJSBSim.a</code>.</p> <ul> <li>JSBSim build for Windows</li> </ul> <p>Go to the workspace area build.flightgear.org:8080/job/JSBSim-win/ws and download all files as a Zip archive. Explore the archive, go to the folder <code>/JSBSim-win/build/src/Debug/</code>, and find: the executable file <code>JSBSim.exe</code> and the static library file <code>JSBSim.lib</code>.</p> <p>This effort of providing pre-compiled binaries of JSBSim is part of the continuous integration and delivery service for the FlightGear project. To learn more about continuous integration with Jenkins you might want to visit this link.</p>","tags":["quickstart"]},{"location":"quickstart/#builds-provided-by-the-jsbsim-team-travis-server-and-appveyor-server","title":"Builds provided by the JSBSim-Team (Travis server and AppVeyor server)","text":"<p>The JSBSim-Team provides its own Continuous Integration service that delivers x64 binaries for both Ubuntu 14.04.5 LTS (Trusty Tahr) and MS Windows. The releases are tagged <code>v2018a</code> (or later) and can be downloaded from the Releases section of the GitHub repository.</p> <p>To check the current status of the latest builds one can go and visit the links:</p> <ul> <li> <p>Travis build for Ubuntu (include tests with both Python 2.7 and 3.6) </p> </li> <li> <p>AppVeyor build for Windows (no tests) </p> </li> </ul> <p> </p>      So, you want to simulate the flight of this aircraft?","tags":["quickstart"]},{"location":"quickstart/building-the-program/","title":"Building the program and the library","text":"<p>JSBSim can either be built with CMake or Microsoft Visual Studio. If you are using a Mac OSX or a Linux platform, you must use CMake. If you are a Windows user you can use either one.</p> <p>JSBSim is coded in standard C++98/C99 and has no dependencies, so all you need is a C/C++ compiler installed on your platform.</p>"},{"location":"quickstart/building-the-program/#building-with-cmake","title":"Building with CMake","text":"<p>CMake is a multiplatform tool to build and test software. It can produce files to build JSBSim with GNU make or Microsoft Visual Studio. To keep the build files separated from the source code, it is preferable to build JSBSim in a separate directory. <pre><code>&gt; cd jsbsim-code\n&gt; mkdir build\n&gt; cd build\n</code></pre> CMake does not build software, it produces files for a multitude of build tools. The following commands are assuming that you are using GNU make to build JSBSim.</p> <p>First, you should invoke CMake and then execute make <pre><code>&gt; cmake ..\n&gt; make\n</code></pre></p> <p>This will compile the various classes, and build the JSBSim application which will be located in <code>build/src</code></p>"},{"location":"quickstart/building-the-program/#options-passed-to-cmake","title":"Options passed to CMake","text":"<p>CMake can use a number of parameters to tune the build of JSBSim. Different options are presented below. You can use them independently or any combination thereof depending on your needs.</p>"},{"location":"quickstart/building-the-program/#passing-parameters-to-the-compiler","title":"Passing parameters to the compiler","text":"<p>If you want to set compiler options, you can pass flags to CMake to build a <code>Debug</code> version of JSBSim. JSBSim also uses C for some code, you can set options for both the C++ and the C compiler. <pre><code>&gt; cmake -DCMAKE_CXX_FLAGS_DEBUG=\"-g -Wall\" -DCMAKE_C_FLAGS_DEBUG=\"-g -Wall\" -DCMAKE_BUILD_TYPE=Debug ..\n&gt; make\n</code></pre> Or alternatively you can build a release version of JSBSim and request GNU Make to use 4 cores to build the executable faster. <pre><code>&gt; cmake -DCMAKE_CXX_FLAGS_RELEASE=\"-O3 -march=native -mtune=native\" -DCMAKE_C_FLAGS_RELEASE=\"-O3 -march=native -mtune=native\" -DCMAKE_BUILD_TYPE=Release ..\n&gt; make -j4\n</code></pre></p>"},{"location":"quickstart/building-the-program/#building-expat-or-using-the-system-library","title":"Building Expat or using the system library","text":"<p>JSBSim uses the Expat library to read XML files. The Expat source code is provided with JSBSim source code and is compiled along with JSBSim during its build. However, if Expat is already installed on your platform you might prefer to use your system Expat library in order to avoid duplication. In that case, you should pass the <code>SYSTEM_EXPAT</code> flag to CMake: <pre><code>&gt; cmake -DSYSTEM_EXPAT=ON ..\n&gt; make\n</code></pre></p>"},{"location":"quickstart/building-the-program/#building-the-python-module-of-jsbsim","title":"Building the Python module of JSBSim","text":"<p>A Python module of JSBSim can also be built by CMake. For that, you need Cython installed on your platform. CMake will automatically detect Cython and build the Python module.</p>"},{"location":"quickstart/building-the-program/#building-with-microsoft-visual-studio","title":"Building with Microsoft Visual Studio","text":"<p>From Visual Studio, you can open the project file <code>JSBSim.vcxproj</code> to open a project for JSBSim. The project file will setup Visual Studio for building JSBSim executable.</p> <p>Note 1: JSBSim official build tool is CMake. Visual studio project files are provided as a convenience and are not guaranteed to be up to date with the code.</p> <p>Note 2: Since Visual Studio 2017, Microsoft has included CMake so you should be able to build JSBSim on VS2017 directly from the CMake file.</p>"},{"location":"quickstart/building-the-program/#testing-jsbsim","title":"Testing JSBSim","text":"<p>JSBSim comes with a test suite to automatically check that the build is correct. This test suite is located in the <code>tests</code> directory and is coded in Python so you need the Python module for JSBSim to be built.</p> <p>The test suite can be run using <code>ctest</code> in the <code>build</code> directory. Tests can be run in parallel on several cores (4 in the example below) using the option <code>-j</code> <pre><code>&gt; ctest -j4\n</code></pre></p>"},{"location":"quickstart/building-the-program/#installing-jsbsim","title":"Installing JSBSim","text":"<p>Once JSBSim is built and tested, you can install the C++ headers and library platform wide. For that, you can invoke GNU make from the <code>build</code> directory <pre><code>&gt; make install\n</code></pre></p>"},{"location":"quickstart/building-the-program/#installing-the-python-module","title":"Installing the Python module","text":"<p>If you plan to install the Python module of JSBSim in addition to the C++ headers and library, then you must pass the flag <code>INSTALL_PYTHON_MODULE</code> to CMake <pre><code>&gt; cmake -DINSTALL_PYTHON_MODULE=ON ..\n&gt; make\n&gt; make install\n</code></pre></p> <p>Alternatively, the Python module can be installed manually by invoking the following commands from the <code>build</code> directory <pre><code>&gt; cd tests\n&gt; python setup.py install\n</code></pre></p> <p> </p>      So, you want to simulate the flight of this aircraft?"},{"location":"quickstart/building-using-visualstudio/","title":"Building using Visual Studio","text":"<p>With the advent of CMake support in Visual Studio 2017 there are now two ways to build JSBSim and the various components using Visual Studio 2017. There is a standard set of Visual Studio project files (<code>*.vcxproj</code>) for the various components like the main JSBSim program, Aeromatic++, etc. and a solution file (<code>*.sln</code>) that references the various project files. Alternatively you can use the new CMake support to build JSBSim and the various components using CMake via Visual Studio.</p> <p>Check out the JSBSim source tree using git. For these examples the source code has been checked out to:</p> <pre><code>C:\\source\\JSBSim\n</code></pre>","tags":["quickstart","building"]},{"location":"quickstart/building-using-visualstudio/#building-using-vs-2017-project-files","title":"Building using VS 2017 Project Files","text":"<p>Use the File \u2192 Open \u2192 Project/Solution \u2026 menu option.</p> <p></p> <p>Browse to the location of the JSBSim source and select the JSBSim.sln in the root of the source code tree, in this example:</p> <pre><code>C:\\source\\JSBSim\\JSBSim.sln\n</code></pre> <p>The project files have been configured to store the compiler and linker\u2019s intermediate files and the final output files in a directory outside of the source code tree of JSBSim, i.e. outside of <code>C:\\source\\JSBSim\\src</code>.</p> <p></p> <p>So for example the intermediate files for JSBSim and Aeromatic will be stored in the following directories:</p> <pre><code>C:\\source\\JSBSim\\Debug\\x64\\JSBSim\nC:\\source\\JSBSim\\Debug\\x64\\aeromatic\n</code></pre> <p>The output files will be found in:</p> <pre><code>C:\\source\\JSBSim\\Debug\n</code></pre>","tags":["quickstart","building"]},{"location":"quickstart/building-using-visualstudio/#building-using-vs-2017-cmake-support","title":"Building using VS 2017 CMake Support","text":"<p>Use the File \u2192 Open \u2192 CMake \u2026 menu option.</p> <p></p> <p>Browse to the location of the JSBSim source and select the CMakeLists.txt in the root of the source code tree, in this example:</p> <pre><code>C:\\source\\JSBSim\\CMakeLists.txt\n</code></pre> <p>There are 4 build configurations in total, x86, x64 and Debug and Release versions for each. Select the build configuration you want to build.</p> <p></p> <p>Then use the CMake menu option to decide which components you would like to build.</p> <p></p> <p>By default Visual Studio configures CMake to build outside the source tree, defaulting to a build directory in the user\u2019s home directory and using a GUID (Globally Unique ID) as part of the directory path. You will see the generated path displayed in the Output window of Visual Studio, for example:</p> <pre><code>Working directory: C:\\Users\\Sean\\CMakeBuilds\\3f00c6d9-d323-5a32-8a90-665138817fd4\\build\\x64-Release\n</code></pre> <p>If for example you don\u2019t want to use your home directory for your CMake builds then you can generate a CMakeSettings.json file by using the CMake \u2192 Change CMake Settings menu option and then editing the buildRoot and installRoot properties.</p> <p></p> <p>Lastly Visual Studio also supports the execution of the JSBSim tests.</p> <p></p> <p></p>","tags":["quickstart","building"]},{"location":"quickstart/getting-support/","title":"Getting support","text":"<p>The best way to get support on JSBSim is to register on GitHub and watch the repository github.com/JSBSim-Team/jsbsim. You can subscribe to individual conversations in issues, pull requests, and team discussions, even if you're not watching the repository or a member of the team where the conversation is occuring. If you're no longer interested in a conversation, you can unsubscribe from any future notifications.</p> <p>To learn more read this guide.</p>","tags":["quickstart","support"]},{"location":"quickstart/getting-the-source/","title":"Getting the source","text":"<p>The GitHub repository of JSBSim is reachable at this link: github.com/JSBSim-Team/jsbsim. This repository mirrors the original one on SourceForge: sourceforge.net/projects/jsbsim.</p>","tags":["quickstart","building"]},{"location":"quickstart/getting-the-source/#what-you-need-to-download-the-source","title":"What you need to download the source","text":"<p>You need to have the Git software installed. Git is a version control software, a system that records changes to a file or set of files over time so that you can recall specific versions later. The JSBSim software source code files are being version controlled by Git.</p> <p>To install Git go to its download site and grab the version for your platform. You can choose to use Git locally on your computer in two ways: via one of the GUI clients, or through a command shell (e.g. a Bash shell on Linux or Windows).</p> <p>Once you have installed Git, assuming you are going to use Git from the command shell, the JSBSim source code public repository can be cloned from one of the two following locations.</p>","tags":["quickstart","building"]},{"location":"quickstart/getting-the-source/#downloading-from-sourceforge","title":"Downloading from SourceForge","text":"<p>In such case the Git command to clone the repo is (HTTPS mode)</p> <pre><code>&gt; git clone https://git.code.sf.net/p/jsbsim/code jsbsim-code\n</code></pre> <p>or (SSH mode)</p> <pre><code>&gt; git clone git://git.code.sf.net/p/jsbsim/code jsbsim-code\n</code></pre>","tags":["quickstart","building"]},{"location":"quickstart/getting-the-source/#downloading-from-github","title":"Downloading from GitHub","text":"<p>in such case the Git command to clone the repo is (HTTPS mode)</p> <pre><code>&gt; git clone https://github.com/JSBSim-Team/jsbsim.git jsbsim-code\n</code></pre> <p>or (SSH mode)</p> <pre><code>&gt; git clone git@github.com:JSBSim-Team/jsbsim.git jsbsim-code\n</code></pre> <p> </p>      So, you want to simulate the flight of this aircraft?","tags":["quickstart","building"]},{"location":"quickstart/running-the-program/","title":"Running the program","text":"<p>The path where the JSBSim repository is located will be called here <code>&lt;JSBSim-root-dir&gt;</code>. If you have built JSBSim from source code there will be an executable (<code>JSBSim</code> on Linux or <code>JSBSim.exe</code> on Windows) under the path <code>&lt;JSBSim-root-dir&gt;/src/</code> subdirectory. This is the JSBSim standalone application, that you might want to copy in the root directory:</p> <pre><code>&lt;JSBSim-root-dir&gt;$ cp src/JSBSim .\n</code></pre> <p>There may be several options specified when running the standalone JSBSim application.</p> <pre><code>&lt;JSBSim-root-dir&gt;$ JSBSim\n\nUsage (items in brackets are optional):\n  JSBSim [script name] [output directive files names] &lt;options&gt;\nOptions:\n--help Returns a usage message\n--version Returns the version number\n--outputlogfile=&lt;filename&gt; Sets/replaces the name of the data log file\n--logdirectivefile=&lt;filename&gt; Sets name of data log directives file\n--root=&lt;path&gt; Sets the JSBSim root directory (where src/ resides)\n--aircraft=&lt;filename&gt; Sets the name of the aircraft to be modeled\n--script=&lt;filename&gt; Specifies a script to run\n--realtime Specifies to run in actual real world time\n--nice Directs JSBSim to run at low CPU usage\n--suspend Specifies to suspend the simulation after initialization\n--initfile=&lt;filename&gt; Specifies an initialization file to use\n--catalog Directs JSBSim to list all properties for this model\n  (--catalog can be specified on the command line along with a --aircraft option,\n  or by itself, while also specifying the aircraft name, e.g. --catalog=c172)\n--end-time=&lt;time&gt; Specifies the sim end time (e.g. time=20.5)\n--property=&lt;name=value&gt; Sets a property to a value.\n  For example: --property=simulation/integrator/rate/rotational=1\n\nNOTE: There can be no spaces around the = sign when an option is followed by a filename\n</code></pre> <p>You can run JSBSim by supplying the name of a script:</p> <pre><code>&lt;JSBSim-root-dir&gt;$ JSBSim --script=scripts/c1723.xml\n</code></pre> <p>TODO</p> <p>Complete page contents.</p> <p> </p>      So, you want to simulate the flight of this aircraft?","tags":["quickstart"]},{"location":"user/","title":"User manual","text":"<p>This section explains how to use JSBSim to make simulation runs, to create aircraft models, to write scripts, and how to perform various other tasks that do not involve changes to program code in JSBSim itself.</p> <p>The JSBSim software comes with many examples of ready-to-use aircraft models. Once they become familiar with all the steps and settings needed to carry out simulations, users might want to look at these examples and learn more in detail the way that some specific models are implemented by more experienced JSBSim users.</p> <p>The aircraft models included in this project and distribution do not include any proprietary, sensitive, or classified data. All data is derived from textbooks (such as Stevens and Lewis \"Aircraft Control and Simulation\" and Sutton's \"Rocket Propulsion Elements\"), freely available technical reports (see: NASA Technical Reports Server site and AIAA website), or other public data (such as the FAA website). Aircraft models included in the JSBSim distribution and with names corresponding to existing commercial or military aircraft are approximations crafted using publicly available information, and are for educational or entertainment uses only.</p>"},{"location":"user/authoring-config-files/","title":"Authoring configuration files","text":"<p>TODO</p> <p>Complete page contents.</p>"},{"location":"user/overview/","title":"Overview","text":""},{"location":"user/overview/#what-exactly-is-jsbsim","title":"What, exactly, is JSBSim?","text":"<p>From an application programming perspective, JSBSim is a collection of program code mostly written in the C++ programming language (but some C language routines are included). Some of the C++ classes that comprise JSBSim model physical entities such as the atmosphere, a flight control system, or an engine. Some of the classes encapsulate concepts or mathematical constructs such as the equations of motion, a matrix, quaternion, or vector. Some classes manage collections of other objects. Taken together, the JSBSim application takes control inputs, calculates and sums the forces and moments that result from those control inputs and the environment, and advances the state of the vehicle (velocity, orientation, position, etc.) in discrete time steps.</p> <p>JSBSim has been built and run on a wide variety of platforms such as a PC running Windows or Linux, Apple Macintosh, and even the IRIX operating system from Silicon Graphics. The free GNU g++ compiler easily compiles JSBSim, and other compilers such as those from Borland and Microsoft also work well. See the Programmers Guide for more information.</p> <p>From an end-user perspective (perhaps a student doing research), JSBSim can be viewed as sort of a \u201cblack box\u201d which is supplied with input files in XML format. These XML files contain descriptions of an aerospace vehicle, engines, scripts, and so on. When these files are loaded into JSBSim, they direct it to model the flight of that vehicle in real-time as part of a larger simulation framework (such as FlightGear or OpenEaagles), or faster than real-time in a batch mode. Each run of JSBSim would result in data files showing performance and dynamics of the vehicle being simulated and studied.</p> <p>From a software integrator perspective (such as someone integrating JSBSim within a larger simulation framework), JSBSim is a library that can be called, supplied with inputs (such as control inputs from the pilot), and returning outputs (describing where the vehicle is at any moment in time).</p>"},{"location":"user/overview/#who-is-it-for-and-how-can-it-be-used","title":"Who is it for, and how can it be used?","text":"<p>The JSBSim flight dynamics model (FDM) software library is meant to be reasonably easy to comprehend, and is designed to be useful to advanced aerospace engineering students. Due to the ease with which it can be configured, it has also proven to be useful to industry professionals in a number of ways. It has been incorporated into larger, full-featured, flight simulation applications and architectures (such as FlightGear, Outerra, and OpenEaagles), and has been used as a batch simulation tool in industry and academia.</p>"},{"location":"user/overview/#examples-of-use","title":"Examples of use","text":""},{"location":"user/overview/#aerocross-echo-hawk","title":"Aerocross Echo Hawk","text":"<p>JSBSim has been used for Hardware-in-the-Loop (HITL) testing of the Aerocross Echo Hawk UAV. Custom code was written to interface with the flight hardware (PC/104-based system) via RS-232/422/485, proportional analog I/O, discrete I/O, and sockets, but the core simulation code was unaltered JSBSim code. Pilot/operator training also relies on JSBSim as the 6-DoF code.</p>"},{"location":"user/overview/#dupont-aerospace-company","title":"DuPont Aerospace Company","text":"<p>JSBSim was used at duPont Aerospace Company along with Matlab for real-time HITL simulation and pilot/operator training. Rex duPont of duPont Aerospace Company explained the project:</p> <p>In the 1990s duPont Aerospace Company was building an airplane to test its concept for a vertical takeoff fan jet transport plane. We had developed a Microsoft Windows-based flight simulator that we had used to test the flying qualities of the proposed craft. However, we needed a simulation that we could use in real time so that we could test the flight characteristics on a full-sized mockup with the flight actuators operating in the loop. We settled on the FlightGear simulator, using the JSBSim flight dynamics model because we could get the full code, it was nicely organized so that we could create new subprograms to match our aircraft, and support was readily available.</p> <p>We developed simultaneously a Matlab simulator for the use in developing more effective autopilot guidance systems, since our primary task became to take the aircraft off using the autopilot alone and to hover in place for 30 seconds. This would show definitively that the control system was sufficiently robust. Therefore, we built into each relevant module of the Matlab simulator and the JSBSim derivative simulator a series of unit tests that provided a sequence of inputs to each model that could be cross verified to ensure that the two systems stayed in sync.</p> <p>We used the JSBSim system to test a number of dynamic issues that were not easily testable with the Matlab model, especially issues involving pilot feel and the controllability during transition to and from hover. These issues are hard to evaluate in the pure control- system world of Matlab because during transition the underlying force structure is continuously varying as aerodynamic forces become more important and pure thrust control forces less.</p> <p>We also did parametric studies on such issues as the sensitivity of the key parameters in the aerodynamic simulation to possible errors in estimation. These were done by having the pilot fly a series of standard maneuvers designed to test the aircraft's response when one or more parameter was degraded by as much as 50% (without the pilot knowing which one was changed).</p> <p>We simulated various servo bandwidths as well, testing to see at what point the flying characteristics became unacceptable. This helped define the characteristics needed. What pilots desire from control systems is almost always different from the optimal theoretical parameters.</p> <p>Additionally, we developed a number of HUD display systems that facilitated operations during hover, where very precise control of ground speed is required. Eventually we achieved a system that allowed a young engineer who did not even have a pilot's license to take off and hold a hover at constant altitude to within one foot for over 30 seconds.</p> <p>We finally achieved our goal of autopilot controlled take-off and hover in two flights of approximately 45 seconds duration on September 30, 2007. Both flights were terminated because one of the engines ran out of fuel, rather than for any control problems.</p>"},{"location":"user/overview/#mitre-air-traffic-studies","title":"MITRE Air Traffic Studies","text":"<p>JSBSim is being used at MITRE in developing a 6-DoF simulation of the FMS (Flight Management System) behavior during CDAs (Continuous Descent Arrival) and OPDs (Optimized Profile Descent). Both the standalone version of JSBSim (for batch runs) and a version integrated with FlightGear have been used. Additional control system components have been created to support specific lateral and vertical navigation studies.</p> <p>JSBSim has also been extended to handle output of messages over a socket to another application used at MITRE which provides a view similar to what an Air Traffic Control operator would see.</p>"},{"location":"user/overview/#us-department-of-transportation","title":"U.S. Department of Transportation","text":"<p>In work done with and for the U.S. D.O.T., a human pilot math model was developed using JSBSim as the 6-DoF (six degree-of-freedom) simulation core.</p>"},{"location":"user/overview/#the-university-of-naples-italy-federico-ii","title":"The University of Naples, Italy, Federico II","text":"<p>The University of Naples has a motion base flying/driving simulator that is driven by FlightGear and JSBSim. The simulator has a three-screen visual presentation that provides a 190 degree field-of-view. The JSBSim source code was modified to provide a force feedback capability.</p> <p>JSBSim has been used at the University of Naples as a tool supporting risk level evaluations of near-ground flight operations. One of the practical problems considered in those collision risk studies consisted in the evaluation of threat posed to flight operations when a new obstacle (such as a building or radar tower) is placed inside the airport area. The risk evaluation has been performed by varying the obstacle geometry and location. The risk assessment procedure has been based on the analysis of statistical deviations of aircraft trajectories from the \u201cnormal\u201d flight path, evaluating the probability of a generic trajectory to cross a given \u201cprotection\u201d area enveloping the potential obstacle. Within this framework, the operational scenario has been formally described and implemented in order to run multiple computer simulations.</p>"},{"location":"user/overview/#fraunhofer-institute-for-wind-energy-systems","title":"Fraunhofer Institute for Wind Energy Systems","text":"<p>In a joint research with the Italian University of Naples Federico II, researchers of Fraunhofer Institute for Wind Energy Systems (IWES) have studied the wake encounter problem occurring when light airplanes fly through or nearby wind turbine wakes.</p> <p>For this research, a framework of software applications has been developed for generating and controlling a population of flight simulation scenarios in presence of assigned wind and turbulence fields. JSBSim was used in the framework as a flight dynamics model, with its autopilot systems adapted for simulating a realistic pilot behavior during navigation. The wind distribution in the turbine wakes were calculated with OpenFOAM, and provided as input for the dynamic model.</p>"},{"location":"user/overview/#tfasa-test-flying-academy-of-south-africa","title":"TFASA - Test Flying Academy of South Africa","text":"<p>The Test Flying Academy of South Africa has been using JSBSim as the basis for a ground based Variable Stability System (VSS) simulator for test pilot training. The aerodynamic stability and control coefficients of a base aircraft model are modified to demonstrate their effect on flying tasks. Actuators are also modelled to show their potential effect on PIO given varying amounts of lag, delay and rate limits.</p> <p>Both fixed wing aircraft and rotary aircraft are simulated with programmable force-feedback inceptors in order to also demonstrate the effects of Flight Control Mechanical Characteristics (FCMC).</p> <p>JSBSim is integrated with Prepar3D to make use of Prepar3D's outside visuals which are rendered on either three large LCDs or connected to a triple projector setup rendering a 180 degree view.</p> <p>TODO</p> <p>Add updated examples of use, 2014+.</p>"},{"location":"user/concepts/flight-control-and-systems-modeling/","title":"Flight Control and System Modelling","text":"<p>Regarding the aircraft as a general dynamical system, it is subject to a vector \\(\\boldsymbol{u}\\) of control inputs. The number and types of inputs may depend on the particular aircraft under consideration. For a conventional configuration aircraft the minimum arrangement of the inputs is usually given by</p> \\[\\begin{equation} \\boldsymbol{u} = \\big[ \\, \\delta_\\mathrm{T}, \\, \\delta_\\mathrm{a}, \\, \\delta_\\mathrm{e}, \\, \\delta_\\mathrm{r} \\,\\big] \\label{eq:Control:Inputs} \\end{equation}\\] <p>where \\(\\delta_\\mathrm{T}\\) is the throttle setting and \\(\\delta_\\mathrm{a}\\), \\(\\delta_\\mathrm{e}\\), and \\(\\delta_\\mathrm{r}\\) are the angular deflections of right ailerons, elevator, and rudder, respectively. These quantities have standard signs and their range may vary according to the particular aircraft design. In flight simulation practice their variation is associated with the normalized setting of a corresponding control in the cockpit.</p> <p>Usually the range of throttle setting goes from 0 (idle) to \\(+1\\) (maximum power). Conceptually \\(\\delta_\\mathrm{T}\\) may be considered as the current fraction of the maximum thrust output available at the actual flight speed and altitude.</p> <p>The stick excursions are all mapped to a range that goes from \\(\u22121\\) to \\(+1\\).</p> <p>These mappings often depend on the presence of control laws that may alter the final effect of pilot action on the actual effector deflections and thrust output.</p> <p>In mathematical terms, whether the actual aerosurface deflections and thrust output or the normalized command ranges are considered, they are seen as a set of bounds for the control variables in the vector \\(\\boldsymbol{u}\\).</p> <p>It has to be underlined, once again, that the number and types of control inputs are a feature of the given aircraft. Even if in the same broad category, two airplane designs might present substantially different arrangements and number of controls. But, generally speaking, at least their 'main' controls are conceptually the same: A pair of ailerons, a main longitudinal control, i.e. a pair of symmetrically moving elevators, and a rudder. In many cases the horizontal empennages have also a variable rigging angle with respect to the fuselage reference line, known as the angle \\(i_\\mathrm{H}\\) in the majority of flight mechanics textbooks.</p>"},{"location":"user/concepts/flight-control-and-systems-modeling/#conventions","title":"Conventions","text":"Standard aircraft aerodynamic control surfaces."},{"location":"user/concepts/flight-control-and-systems-modeling/#overview-on-aerodynamic-modelling","title":"Overview on Aerodynamic Modelling","text":"<p>Linearized pitch coefficient:</p> \\[\\begin{equation} C_m = C_{m0} + C_{m\\alpha} \\, \\alpha_\\mathrm{B} + C_{m\\delta_\\mathrm{e}} \\delta_\\mathrm{e} + C_{m i_\\mathrm{H}} \\, i_\\mathrm{H} + \\left( C_{mq} \\, q + C_{m\\dot{\\alpha}} \\, \\dot{\\alpha}_\\mathrm{B}\\right) \\frac{\\bar{c}}{2V} \\label{eq:Cm} \\end{equation}\\] <p> </p> <p>     The command to deflection logic for the elevator channel in the c172p model. The combination of yoke movement and pitch trim lever regulation is normalized and mapped to the interval \\([\u22121, 1]\\). The output of the channel is a real variable fcs/elevator-pos-rad representing an equivalent elevator deflection \\(\\delta_\\mathrm{e}^\\star = \\delta_\\mathrm{e} + \\delta_\\mathrm{e,tab}^\\star\\). The angle \\(\\delta_\\mathrm{e,tab}^\\star\\) is an elevator deflection equivalent to the actual tab angle \\(\\delta_\\mathrm{e,tab}\\). The \\(\\delta_\\mathrm{e}\\) varies in the range \\([\\delta_\\mathrm{e,min}, \\delta_\\mathrm{e,max}]\\). The tail is represented with the moving surfaces deflected both in the equivalent condition (top), and in the actual condition (bottom).   </p>"},{"location":"user/concepts/flight-control-and-systems-modeling/#overview-on-propulsion-modelling","title":"Overview on Propulsion Modelling","text":"A twin engine propeller aircraft. Location in body frame of the engine thruster, of thrust application point, and thrust vector orientation.         Locations associated to the entities 'thruster' and 'tank' in the FDM of c172p."},{"location":"user/concepts/forces-and-moments/","title":"Forces and Moments","text":""},{"location":"user/concepts/forces-and-moments/#aerodynamics","title":"Aerodynamics","text":"<p>There are several ways to model the aerodynamic forces and moments (torques) that act on an aircraft. JSBSim started out by using the coefficient buildup method. In the coefficient buildup method, the lift force (for instance) is determined by summing all of the contributions to lift. The contributions differ depending on the aircraft and the fidelity of the model, but contributions to lift can include those from:</p> <ul> <li>Wing</li> <li>Elevator</li> <li>Flaps</li> </ul> <p>Aerodynamic coefficients are numbers which, when multiplied by certain other values (such as dynamic pressure and wing area), result in a force or moment. The coefficients can be taken from flight test reports or textbooks, or they can be calculated using software (such as Digital DATCOM or other commercially available programs) or by hand calculations. Eventually, JSBSim added support for aerodynamic properties specified as functions. Within the <code>&lt;aerodynamics&gt;</code> section of a configuration file there are six subsections representing the 3 force and 3 moment axes (for a total of six degrees of freedom). The basic layout of the aerodynamics section is as follows:</p> <pre><code>&lt;aerodynamics&gt;\n&lt;axis name=\"DRAG\"&gt;\n{ force contributions }\n   &lt;/axis&gt;\n&lt;axis name=\"SIDE\"&gt;\n{ force contributions }\n   &lt;/axis&gt;\n&lt;axis name=\"LIFT\"&gt;\n{ force contributions }\n   &lt;/axis&gt;\n&lt;axis name=\"ROLL\"&gt;\n{ moment contributions }\n   &lt;/axis&gt;\n&lt;axis name=\"PITCH\"&gt;\n{ moment contributions }\n   &lt;/axis&gt;\n&lt;axis name=\"YAW\"&gt;\n{ moment contributions }\n   &lt;/axis&gt;\n&lt;/aerodynamics&gt;\n</code></pre> <p>Individual axes are not all absolutely required. There are several standard grouped sets of axes that are supported in JSBSim:</p> <ul> <li><code>\"DRAG\"</code>, <code>\"SIDE\"</code>, <code>\"LIFT\"</code> (wind axes)</li> <li><code>\"X\"</code>, <code>\"Y\"</code>, <code>\"Z\"</code> (body axes)</li> <li><code>\"AXIAL\"</code>, <code>\"SIDE\"</code>, <code>\"NORMAL\"</code> (body axes)</li> </ul> <p>All three systems accept <code>\"ROLL\"</code>, <code>\"PITCH\"</code>, <code>\"YAW\"</code> axis definitions. The axial systems cannot be mixed. Within the axis elements, functions are used to define individual force or moment contributions to the total for that axis. Functions are used throughout JSBSim. In defining a force or moment, functions can employ the use of tables, constants, trigonometric functions, or other standard C library functions. Simulation parameters are referenced via properties. Here is an example:</p> <pre><code>&lt;function name=\"aero/force/lift_due_to_flap_deflection\"&gt;\n&lt;description&gt;Lift contribution due to flap deflection&lt;/description&gt;\n&lt;product&gt;\n&lt;property&gt;aero/function/ground-effect-factor-lift&lt;/property&gt;\n&lt;property&gt;aero/qbar-area&lt;/property&gt;\n&lt;table&gt;\n&lt;independentVar&gt;fcs/flap-pos-deg&lt;/independentVar&gt;\n&lt;tableData&gt;\n0.0  0.0\n            10.0  0.20\n            20.0  0.30\n            30.0  0.35\n         &lt;/tableData&gt;\n&lt;/table&gt;\n&lt;/product&gt;\n&lt;/function&gt;\n</code></pre> <p>In this case, a description in words of what the above does is as follows: the value of the function is the product of the <code>ground-effect-factor-lift</code>, <code>qbar-area</code>, and the value determined by the table, which is indexed as a function of flap position in degrees.</p> <p>All of the functions in an <code>&lt;axis/&gt;</code> section are summed and applied to the aircraft in the appropriate manner. There is some flexibility in this format, though. Functions that are specified outside of any <code>&lt;axis/&gt;</code> section are created and calculated, but they do not specifically contribute to any force or moment total by themselves. However, they can be referenced by other functions that are in an <code>&lt;axis/&gt;</code> section. This technique allows calculations that might be applied to several individual functions to be performed once and used several times. The technique can be taken even further, with actual aerodynamic coefficients being calculated outside of an <code>&lt;axis/&gt;</code> definition, with the coefficients subsequently being multiplied within function definitions by the various factors (properties) that turn them into forces and moments inside an <code>&lt;axis/&gt;</code> definition.</p> <p>As an example, let\u2019s examine the instantaneous lift force \\(L(t)\\). It is expressed with the following build-up formula:</p> \\[ L = L_\\mathrm{basic} \\big(\\alpha_\\mathrm{B},\\phi_\\mathrm{hyst}\\big) + \\Delta L \\big(\\delta_\\mathrm{flap}\\big) + \\Delta L \\big(\\delta_\\mathrm{e}\\big) + \\Delta L \\big(\\dot{\\alpha}_\\mathrm{B}\\big) + \\Delta L \\big( q \\big) \\label{eq:Build:Up:Formula:Lift} \\] <p>where \\(\\alpha_\\mathrm{B}\\), \\(\\delta_\\mathrm{flap}\\), \\(\\delta_\\mathrm{e}\\), \\(\\dot{\\alpha}_\\mathrm{B}\\) and \\(q\\) are the well-known aircraft state variables. The non-dimensional scalar \\(\\phi_\\mathrm{hyst}\\) is usually equal to 0 and becomes 1 at high angles of attack (near stall situations, when aerodynamic hysteresis effects are modeled).</p> <p>The term \\(L_\\mathrm{basic} \\big(\\alpha_\\mathrm{B},\\phi_\\mathrm{hyst}\\big)\\) in (\\(\\ref{eq:Build:Up:Formula:Lift}\\)) is called the \u201cbasic\u201d contribution to the build-up and is dependent on the angle of attack. We know that increasing the angle of attack increases lift \u2014 up to a point. Lift force is traditionally defined as the product of filght dynamic pressure (\u201cqbar\u201d, \\(\\bar{q}\\), or \\(\\bar{q}_\\infty\\) for aerodynamicists), wing area (\\(S_\\mathrm{W}\\) or simply \\(S\\)), and lift coefficient (\\(C_L\\)). In this case, the lift coefficient is determined via a lookup table, using \\(\\alpha_\\mathrm{B}\\) and \\(\\phi_\\mathrm{hyst}\\) as an index into the table:</p> <pre><code>&lt;function name=\"aero/force/lift_from_alpha\"&gt;\n&lt;description&gt; Lift due to alpha &lt;/description&gt;\n&lt;product&gt;\n&lt;property&gt; aero/qbar-psf &lt;/property&gt;\n&lt;property&gt; metrics/Sw-sqft &lt;/property&gt;\n&lt;property&gt; aero/function/kCLge &lt;/property&gt;\n&lt;table&gt;\n&lt;independentVar lookup=\"row\"&gt; aero/alpha-rad &lt;/independentVar&gt;\n&lt;independentVar lookup=\"column\"&gt; aero/stall-hyst-norm &lt;/independentVar&gt;\n&lt;tableData&gt;\n0.0000   1.0000\n            -0.0900  -0.2200  -0.2200\n             0.0000   0.2500   0.2500\n             0.0900   0.7300   0.7300\n             0.1000   0.8300   0.7800\n             0.1200   0.9200   0.7900\n             0.1400   1.0200   0.8100\n             0.1600   1.0800   0.8200\n             0.1700   1.1300   0.8300\n             0.1900   1.1900   0.8500\n             0.2100   1.2500   0.8600\n             0.2400   1.3500   0.8800\n             0.2600   1.4400   0.9000\n             0.2800   1.4700   0.9200\n             0.3000   1.4300   0.9500\n             0.3200   1.3800   0.9900\n             0.3400   1.3000   1.0500\n             0.3600   1.1500   1.1500\n         &lt;/tableData&gt;\n&lt;/table&gt;\n&lt;/product&gt;\n&lt;/function&gt;\n</code></pre> <p>The basic lift coefficient</p> \\[ C_{L,\\mathrm{basic}} = \\frac{L_\\mathrm{basic} \\big(\\alpha_\\mathrm{B},\\phi_\\mathrm{hyst}\\big) }{\\bar{q} S} \\label{eq:Build:Up:Formula:Lift:Coefficient} \\] <p>is plotted below as a function of \\(\\alpha_\\mathrm{B}\\) and \\(\\phi_\\mathrm{hyst}\\).</p> <p> </p> <p>     The plotted function of two variables \\(C_{L,\\mathrm{basic}}\\big(\\alpha_\\mathrm{B},\\phi_\\mathrm{hyst}\\big)\\) corresponding to the tabular function named 'aero/coefficient/CLwbh' in the aerodynamic model of c172p.   </p> <p>TODO</p> <p>Complete subsection.</p> <p> </p> <p>     The plotted function of two variables \\(C_{D,\\mathrm{basic}}\\big(\\alpha_\\mathrm{B},\\delta_\\mathrm{flap}\\big)\\) corresponding to the tabular function named 'aero/coefficient/CDwbh' in the aerodynamic model of c172p.   </p> <p>TODO</p> <p>Complete the following subsections.</p>"},{"location":"user/concepts/forces-and-moments/#propulsion","title":"Propulsion","text":""},{"location":"user/concepts/forces-and-moments/#weight","title":"Weight","text":""},{"location":"user/concepts/forces-and-moments/#ground-contact","title":"Ground Contact","text":""},{"location":"user/concepts/frames-of-reference/","title":"Frames of Reference","text":"<p>Before moving into a description of the configuration file syntax, one must understand some basic information about some of the frames of reference used (i) in describing the location of objects on the aircraft, (ii) in specifying conditions related to the position and orientation of the aircraft in space, or (iii) when assigning inputs for a given flight condition.</p> <p>Learn more on Wikipedia about axes conventions.</p>"},{"location":"user/concepts/frames-of-reference/#structural-or-construction-frame","title":"Structural, or \"Construction\" Frame","text":"<p>This frame is a common manufacturer's frame of reference and is used to define points on the aircraft such as the center of gravity, the locations of all the wheels, the pilot eye-point, point masses, thrusters, and so on. Items in the JSBSim aircraft configuration file are located using this frame.</p> <p>In the structural frame the X-axis runs along the fuselage length and points towards the tail, the Y-axis points from the fuselage out towards the right wing, and of course the Z-axis then is positive upwards. Typically, the origin \\(O_\\mathrm{C}\\) for this frame is near the front of the aircraft (at the tip of the nose, at the firewall for a single engine airplane, or at some distance in front of the nose). This frame is often named \\(\\mathcal{F}_\\mathrm{C} = \\{O_\\mathrm{C}, x_\\mathrm{C}, y_\\mathrm{C}, z_\\mathrm{C}\\}\\).</p> <p> </p> <p>     Aircraft structural (or construction) frame of reference with origin \\(O_\\mathrm{C}\\). Besides the structural frame axes \\(x_\\mathrm{C}\\), \\(y_\\mathrm{C}\\), and \\(z_\\mathrm{C}\\), the standard body frame axes \\(x_\\mathrm{B}\\), \\(y_\\mathrm{B}\\), and \\(z_\\mathrm{B}\\) are also shown with their origin at the center of mass \\(G\\). The pilot's eye-point is located at \\(P_\\mathrm{EP}\\).   </p> <p>The X-axis is typically coincident with the fuselage centerline and often is coincident with the thrust axis (for instance, in single engine propeller aircraft it passes through the propeller hub). Positions along the \\(x_\\mathrm{C}\\) axis are referred to as stations. Positions along the \\(z_\\mathrm{C}\\) axis are referred to as waterline positions. Positions along the \\(y_\\mathrm{C}\\) axis are referred to as buttline positions.</p> <p> </p> <p>     A screenshot taken from the 3D modeling software Blender. The scene shows a model of Cessna 172 with its structural frame \\(\\mathcal{F}_\\mathrm{C} = \\{O_\\mathrm{C}, x_\\mathrm{C}, y_\\mathrm{C}, z_\\mathrm{C}\\}\\). The origin \\(O_\\mathrm{C}\\) in this case is located inside the cockpit, near the dashboard.   </p> <p>Note that the origin can be anywhere for a JSBSim-modeled aircraft, because JSBSim internally only uses the relative distances between the CG and the various objects --- not the absolute locations themselves.</p> <p> </p> <p>     Center of gravity (CG) position, point \\(G\\), determined in a construction frame.   </p> <p> </p> <p>     Definition of ground contact points in terms of construction frame locations.   </p> <p> </p> <p>     Two key point locations \\(P_\\mathrm{ARP}\\) and \\(P_\\mathrm{CG,EW}\\) in the structural frame, respectively, he pole of aerodynamic moments and the Empty Weight CG of the airframe. The shape of the wing root profile and its chord are also sketched.   </p> <p> </p> <p>     Besides point \\(P_\\mathrm{CG,EW}\\), are represented two more significant locations, \\(P_\\mathrm{Pilot}\\) and \\(P_\\mathrm{Right\\,Pass}\\), where two additional masses are concentrated, respectively, of the pilot and of the right passenger.   </p>"},{"location":"user/concepts/frames-of-reference/#body-frame","title":"Body Frame","text":"<p>In JSBSim, the body frame is similar to the structural frame, but rotated 180 degrees about the \\(y_\\mathrm{C}\\), with the origin coincident with the CG. Typycally, the body frame is defined by knowning the position of the airplane's center of mass \\(G\\) and the direction of the longitudinal construction axis \\(x_\\mathrm{C}\\). The axis \\(x_\\mathrm{B}\\) shall be chosen such that it originates from \\(G\\), it is parallel to \\(x_\\mathrm{C}\\), and with a positive verse from \\(G\\) towards the fuselage nose.</p> <p>The frame of body axes is often called \\(\\mathcal{F}_\\mathrm{B} = \\{G, x_\\mathrm{B}, y_\\mathrm{B}, z_\\mathrm{B}\\}\\). The \\(x_\\mathrm{B}\\) axis is called the roll axis and points forward, the \\(y_\\mathrm{B}\\) axis is called pitch axis and points toward the right wing, the \\(z_\\mathrm{B}\\) axis is called yaw axis and points towards the fuselage belly.</p> <p> </p> <p>     Standard aircraft body axis frame, with origin at the center of gravity \\(G\\).   </p> <p>In the body frame the aircraft forces and moments are summed and the resulting accelerations are integrated to get velocities.</p>"},{"location":"user/concepts/frames-of-reference/#stability-or-aerodynamic-frame","title":"Stability, or \"Aerodynamic\" Frame","text":"<p>This frame is defined according to the instantaneous orientation of the relative wind vector with respect to the airframe. If, for simplicity, the air is still with respect to the Earth (no wind), and \\(\\boldsymbol{V}\\) is the aircraft center-of-mass velocity vector with respect to the Earth-fixed observer (also named \\(\\boldsymbol{V}_\\mathrm{CM/E}\\) to emphasize the relative motion), then \\(-\\boldsymbol{V}\\) is the relative wind velocity and \\(V = \\|\\boldsymbol{V}\\|\\) is the airspeed.</p> <p>The frame, named \\(\\mathcal{F}_\\mathrm{A} = \\{ G, x_\\mathrm{A}, y_\\mathrm{A}, z_\\mathrm{A} \\}\\), has the axis \\(x_\\mathrm{A}\\) that points into the relative wind vector projected onto the aircraft plane of symmetry \\(x_\\mathrm{B} z_\\mathrm{B}\\). The axis \\(y_\\mathrm{A}\\) still points out the right wing and coincides with the body axis \\(y_\\mathrm{B}\\), and the axis \\(z_\\mathrm{A}\\) completes the right-hand system.</p> <p> </p> <p>     Aerodynamic frame, defining the aerodynamic angles \\(\\alpha_\\mathrm{B}\\) and \\(\\beta\\).   </p> <p>The two axes \\(x_\\mathrm{A}\\) and \\(z_\\mathrm{A}\\) belong, by definition, to the aircraft symmetry plane, but they can rotate during flight because the orientation of the relative wind velocity vector \\(\\boldsymbol{V}\\) might change with respect to the vehicle. The above figure shows how the aerodynamic frame is constructed. The angle between the two axes \\(x_\\mathrm{A}\\) and \\(x_\\mathrm{B}\\) is the aircraft angle of attack \\(\\alpha_\\mathrm{B}\\). The angle formed by the instantaneous direction of \\(\\boldsymbol{V}\\) and its projection on the plane \\(x_\\mathrm{B} z_\\mathrm{B}\\) is the sideslip angle \\(\\beta\\).</p> <p>This frame, called stability frame in some manuals, is also named here 'aerodynamic frame' because the projection \\(Z_\\mathrm{A}\\) of the instantaneous aerodynamic resultant force \\(\\mathcal{F}_\\mathrm{A}\\) onto the axis \\(z_\\mathrm{A}\\) defines the aerodynamic lift. In particular, the lift \\(L\\) is such that \\(-L\\) is the component of \\(\\mathcal{F}_\\mathrm{A}\\) along \\(z_\\mathrm{A}\\), i.e. \\(Z_\\mathrm{A}=-L\\).</p> <p>To visualize the above observation, consider a typical maneuver studied in flight mechanics: the zero-sideslip (or 'coordinated'), constant altitude turn at steady airspeed. In this situation the wings are banked and so is the lift. In such a turn \\(\\mathcal{F}_\\mathrm{A}\\) is banked and \\(x_\\mathrm{A}\\) is kept horizontal. In general terms, the lift as a vector is always defined in the aircraft symmetry plane.</p> <p> </p> <p>     Banked lift in a steady coordinated turn at constant altitude. The bank angle \\(\\phi_\\mathrm{W}\\) is a rotation around the relative wind velocity vector. The motion is freezed in time when the velocity vector is aligned with the North. Coordinated turn means that \\(\\beta=0\\) and constant altitude means that \\(x_\\mathrm{A}\\) is kept horizontal.   </p> <p>Remark --- In dynamic stability studies what is referred to as 'stability frame' is something slightly different from the aerodynamic frame introduced above: The stability frame in aircraft flight dynamics and stability conventions is nothing but a particular kind of body-fixed frame, defined with respect to an initial symmetrical, steady, wings-level, constant altitude flight condition. This conditions gives the direction of \\(x_\\mathrm{S}\\) (which coincides with \\(x_\\mathrm{A}\\) at that particular flight attitude). Therefore, in dynamic stability studies the stability frame, unlike the aerodynamic frame, is fixed with the vehicle.</p> <p>In JSBSim the notion of stability frame \\(\\mathcal{F}_\\mathrm{S} = \\{ G, x_\\mathrm{S}, y_\\mathrm{S}, z_\\mathrm{S} \\}\\) is used to mean the aerodynamic frame.</p>"},{"location":"user/concepts/frames-of-reference/#earth-centered-inertial-frame-eci-and-earth-centered-earth-fixed-frame-ecef","title":"Earth-Centered Inertial Frame (ECI) and Earth-Centered Earth-Fixed Frame (ECEF)","text":"<p>The Earth-Centered Inertial frame (or simply 'inertial frame') \\(\\mathcal{F}_\\mathrm{ECI} = \\{ O_\\mathrm{ECI}, x_\\mathrm{ECI}, y_\\mathrm{ECI}, z_\\mathrm{ECI} \\}\\) is fixed with its origin at the center of the Earth. Its cartesian axes remain fixed relative to the stars, and provide a reference frame for which the aircraft (or spacecraft) equations of motion are most simply expressed. The positive \\(z_\\mathrm{ECI}\\) axis passes through the Earth's geographic North Pole. The \\(x_\\mathrm{ECI}\\) and \\(y_\\mathrm{ECI}\\) axes lie in the equatorial plane. The axis \\(x_\\mathrm{ECI}\\) is always parallel to a line from the Sun's center of mass to Earth's position in orbit at the vernal equinox. The ECI system is shown in the next figure.</p> <p> </p> <p>     Earth-Centered Inertial (ECI) frame and Earth-Centered Earth-Fixed (ECEF) frame.   </p> <p>The axes of the Earth-Centered, Earth-Fixed (ECEF) frame of reference, labeled \\(x_\\mathrm{ECEF}\\), \\(y_\\mathrm{ECEF}\\), and \\(z_\\mathrm{ECEF}\\), are also depicted in the above figure. The ECEF coordinate axes remain fixed with respect to the Earth. The origin \\(O_\\mathrm{ECEF}\\) of this cartesian system, like the inertial frame, is located at the mass center of the earth. The \\(z_\\mathrm{ECEF}\\) axis also lies along the Earth's spin axis and coincides with \\(z_\\mathrm{ECI}\\). The \\(x_\\mathrm{ECEF}\\) and \\(y_\\mathrm{ECEF}\\) axes both lie in the equatorial plane, with the positive \\(x_\\mathrm{ECEF}\\) axis passing through the prime meridian (Greenwich Meridian). The ECEF frame rotates counter-clockwise about the Inertial frames \\(z_\\mathrm{ECI}\\) axis with angular velocity \\(\\omega_\\mathrm{E}\\). The Earth angular rate \\(\\omega_\\mathrm{E}\\) is approximately equal to \\(2\\pi/24\\) radians/hour.</p>"},{"location":"user/concepts/frames-of-reference/#north-oriented-tangent-frames","title":"North-Oriented Tangent Frames","text":"<p>A tangent-plane coordinate system can be defined when a matemathical representation of Earth's surface is assumed (a spheroid or an approximating sphere). A plane tangent to a point of interest on the surface \\(O_\\mathrm{E}\\) is taken as a reference. A geographic system called North-Oriented Tangent Frame \\(\\mathcal{F}_\\mathrm{E} = \\{ O_\\mathrm{E}, x_\\mathrm{E}, y_\\mathrm{E}, z_\\mathrm{E}\\}\\) has its origin fixed at the point of interest \\(O_\\mathrm{E}\\) and its plane \\(x_\\mathrm{E} y_\\mathrm{E}\\) coincident with the tangent plane. The axis \\(x_\\mathrm{E}\\) points towards the geographic North, the axis \\(y_\\mathrm{E}\\) points towards the East. Finally, the axis \\(z_\\mathrm{E}\\) points downwards towards the center of the Earth. For this reason the frame \\(\\mathcal{F}_\\mathrm{E}\\) is also called tangent NED frame (North-East-Down).</p> <p> </p> <p>     Earth-Centered Earth-Fixed (ECEF) frame, geografic coordinates, Tangent (T) frame, and local Vertical (V) frame.   </p>"},{"location":"user/concepts/frames-of-reference/#local-vertical-local-level-frame-or-local-ned-frame","title":"Local-Vertical Local-Level Frame, or Local NED Frame","text":"<p>The local vertical frame \\(\\mathcal{F}_\\mathrm{V} = \\{ G, x_\\mathrm{V}, y_\\mathrm{V}, z_\\mathrm{V}\\}\\) is unrelated to the airplane's orientation in space but is only defined by its CG position with respect to some convenient Earth-fixed observer. If \\(G_\\mathrm{GT}\\) is the CG projected on the ground ('ground tracked'), the coordinate plane \\(x_\\mathrm{V} y_\\mathrm{V}\\) is parallel to a plane locally tangent in \\(G_\\mathrm{GT}\\) to the Earth's surface --- i.e. the plane \\(x_\\mathrm{E} y_\\mathrm{E}\\) with \\(O_\\mathrm{E} \\equiv G_\\mathrm{GT}\\). Then, the axis \\(x_\\mathrm{V}\\) points towards the geographic North, the axis \\(y_\\mathrm{V}\\) points towards the East. Finally, the axis \\(z_\\mathrm{V}\\) points downwards towards the center of the Earth. For this reason the frame \\(\\mathcal{F}_\\mathrm{V}\\) is also called local NED (vehicle-carried) frame.</p> <p> </p> <p>     Aircraft body frame and local vertical frame (NED frame). The aircraft Euler angles are also shown: the heading angle \\(\\psi\\) (negative in the picture), the elevation angle \\(\\theta\\), and the roll angle \\(\\phi\\).   </p> <p>The NED convention ensures that the aircraft weight is a force with components \\((0,0,mg)\\) in the frame \\(\\mathcal{F}_\\mathrm{V}\\), where \\(m\\) is the airplane's mass and \\(g\\) is the gravitational acceleration.</p> <p>The above figure shows an aircraft with the two frames \\(\\mathcal{F}_\\mathrm{V}\\) and \\(\\mathcal{F}_\\mathrm{B}\\). The Euler angles that define the body frame orientation with respect to the local NED frame are the aircraft Euler angles. For atmospheric flight vehicles the sequence of rotations used to define the Euler angles is '3-2-1'. This defines the heading angle \\(\\psi\\), the elevation angle \\(\\theta\\), and the roll angle \\(\\phi\\) with respect to an observer fixed with the Earth.</p> <p> </p> <p>     Euler angle sequence for an aircraft. The frame \\(\\mathcal{F}_\\mathrm{E} = \\{ O_\\mathrm{E}, x_\\mathrm{E}, y_\\mathrm{E}, z_\\mathrm{E}\\}\\) is an Earth-fixed NED coordinate system, with origin the \\(O_\\mathrm{E}\\) somewhere on the ground (or at see level) and the plane \\(x_\\mathrm{E} y_\\mathrm{E}\\) tangent to the Earth surface. If the ground track point \\(G_\\mathrm{GT}\\) is not too far from \\(O_\\mathrm{E}\\), the Earth frame \\(\\mathcal{F}_\\mathrm{E}\\) axes are parallel to those of the local NED frame \\(\\mathcal{F}_\\mathrm{V} = \\{ G, x_\\mathrm{V}, y_\\mathrm{V}, z_\\mathrm{V}\\}\\).   </p>"},{"location":"user/concepts/frames-of-reference/#wind-frame","title":"Wind Frame","text":"<p>Besides the lift, the instantaneous aerodynamic resultant force vector \\(\\mathcal{F}_\\mathrm{A}\\) has two more components in a frame of reference of which \\(z_\\mathrm{A}\\) is the third axis. This frame is called wind frame \\(\\mathcal{F}_\\mathrm{W} = \\{ G, x_\\mathrm{W}, y_\\mathrm{W}, z_\\mathrm{W}\\}\\).</p> <p>The wind frame is defined by taking the \\(x_\\mathrm{W}\\) axis along the relative wind with a positive verse in the direction of motion. This means that \\(x_\\mathrm{W}\\) is superimposed to the vector \\(\\boldsymbol{V}\\). The third axis of \\(\\mathcal{F}_\\mathrm{W}\\) is taken along the lift line of action, i.e. \\(z_\\mathrm{W} \\equiv z_\\mathrm{A}\\). Finally, the second axis \\(y_\\mathrm{W}\\) is chosen in order to complete the right-handed triad. The wind frame has its third axis constantly in the airframe plane of symmetry (also called the 'reference plane'). All the three wind axes rotate with respect to the body axes because of the changing attitude of the aircraft with respect to the relative wind \\(-\\boldsymbol{V}\\).</p> <p>The component \\(X_\\mathrm{W}\\) of the force vector \\(\\mathcal{F}_\\mathrm{A}\\) along the direction of \\(\\boldsymbol{V}\\) defines the aerodynamic drag: The drag \\(D\\) is such that \\(X_\\mathrm{W}=-D\\). In presence of a nonzero sideslip angle \\(\\beta\\), a third nonzero component of \\(\\mathcal{F}_\\mathrm{A}\\) arises along the lateral axis \\(y_\\mathrm{W}\\), i.e. the side force component \\(Y_\\mathrm{W}\\).</p> <p>When the sideslip angle \\(\\beta\\) is zero, the wind frame and the aerodynamic frame are coincident. Only in this circumstance \\(y_\\mathrm{W}\\), being coincident with \\(y_\\mathrm{A}\\) and \\(y_\\mathrm{B}\\), is normal to the reference plane \\(x_\\mathrm{B} z_\\mathrm{B}\\).</p> <p>The figure below shows the standard frames of reference for an aircraft in climbing flight in calm air. The wind frame \\(\\mathcal{F}_\\mathrm{W}\\) can be made superimposed to the aerodynamic frame \\(\\mathcal{F}_\\mathrm{A}\\) when rotated around \\(z_\\mathrm{W}\\) of the angle \\(-\\beta\\).</p> <p> </p> <p>     Standard frames of reference and aircraft in climbing flight in calm air. The CG velocity vector \\(\\boldsymbol{V}\\) forms the flight path angle \\(\\gamma\\) with the horizontal plane. The standard three aerodynamic resultant force components \\(D\\), \\(L\\) and \\(Y_\\mathrm{A}\\) are also shown.   </p> <p>Consequently, the wind frame \\(\\mathcal{F}_\\mathrm{W}\\) can be superimposed to the body frame \\(\\mathcal{F}_\\mathrm{B}\\) when rotated first around \\(z_\\mathrm{W}\\) of the angle \\(-\\beta\\) then around the axis \\(y_\\mathrm{A}\\) of the angle \\(\\alpha_\\mathrm{B}\\):</p> \\[ \\mathcal{F}_\\mathrm{W} \\stackrel{-\\beta \\, \\curvearrowright \\, z_\\mathrm{W}}{ \\longrightarrow } \\mathcal{F}_\\mathrm{A} \\stackrel{\\alpha_\\mathrm{B} \\, \\curvearrowright \\, y_\\mathrm{A}}{ \\longrightarrow } \\mathcal{F}_\\mathrm{B} \\label{eq:FW:To:FB} \\] <p>The components of the aerodynamic resultant force in body axes are then expressed as follows:</p> \\[ \\left\\{\\begin{matrix}   X_\\mathrm{B} \\\\ Y_\\mathrm{B} \\\\ Z_\\mathrm{B} \\end{matrix}\\right\\} = \\left[\\begin{matrix}   \\cos\\alpha_\\mathrm{B} &amp; 0 &amp; -\\sin\\alpha_\\mathrm{B} \\\\   0 &amp; 1 &amp; 0 \\\\   \\sin\\alpha_\\mathrm{B} &amp; 0 &amp; \\cos\\alpha_\\mathrm{B} \\end{matrix}\\right]   \\left[\\begin{matrix}     \\cos\\beta &amp; \\sin(-\\beta) &amp; 0 \\\\     -\\sin(-\\beta) &amp; \\cos\\beta &amp; 0 \\\\     0 &amp; 0 &amp; 1   \\end{matrix}\\right]   \\left\\{\\begin{matrix}     -D \\\\ Y_\\mathrm{W} \\\\ -L   \\end{matrix}\\right\\} \\label{eq:DYL:To:XYZB}   \\] <p>in terms of drag, side force and lift.</p>"},{"location":"user/concepts/math/","title":"Math","text":""},{"location":"user/concepts/math/#functions","title":"Functions","text":"<p>The function specification in JSBSim is a powerful and versatile resource that allows algebraic functions to be defined in a JSBSim configuration file. The function syntax is similar in concept to MathML (Mathematical Markup Language, http://www.w3.org/Math/), but it is simpler and more terse.</p> <p>A function definition consists of an operation, a value, a table, or a property (which evaluates to a value). The currently supported operations are:</p> <ul> <li><code>sum</code> (takes n arguments)</li> <li><code>difference</code> (takes n arguments)</li> <li><code>product</code> (takes n arguments)</li> <li><code>quotient</code> (takes 2 arguments)</li> <li><code>pow</code> (takes 2 arguments)</li> <li><code>exp</code> (takes 2 arguments)</li> <li><code>abs</code> (takes n arguments)</li> <li><code>sin</code> (takes 1 arguments)</li> <li><code>cos</code> (takes 1 arguments)</li> <li><code>tan</code> (takes 1 arguments)</li> <li><code>asin</code> (takes 1 arguments)</li> <li><code>acos</code> (takes 1 arguments)</li> <li><code>atan</code> (takes 1 arguments)</li> <li><code>atan2</code> (takes 2 arguments)</li> <li><code>min</code> (takes n arguments)</li> <li><code>max</code> (takes n arguments)</li> <li><code>avg</code> (takes n arguments)</li> <li><code>fraction</code> (takes 1 argument)</li> <li><code>mod</code> (takes 2 arguments)</li> <li><code>lt</code> (less than, takes 2 args)</li> <li><code>le</code> (less equal, takes 2 args)</li> <li><code>gt</code> (greater than, takes 2 args)</li> <li><code>ge</code> (greater than, takes 2 args)</li> <li><code>eq</code> (equal, takes 2 args)</li> <li><code>nq</code> (not equal, takes 2 args)</li> <li><code>and</code> (takes n args)</li> <li><code>or</code> (takes n args)</li> <li><code>not</code> (takes 1 args)</li> <li><code>if-then</code> (takes 2-3 args)</li> <li><code>switch</code> (takes 2 or more args)</li> <li><code>random</code> (Gaussian random number, takes no arguments)</li> <li><code>integer</code> (takes one argument)</li> </ul> <p>An operation is defined in the configuration file as in the following example:</p> <pre><code>&lt;sum&gt;\n&lt;value&gt; 3.14159 &lt;/value&gt;\n&lt;property&gt; velocities/qbar &lt;/property&gt;\n&lt;product&gt;\n&lt;value&gt; 0.125 &lt;/value&gt;\n&lt;property&gt; metrics/wingarea &lt;/property&gt;\n&lt;/product&gt;\n&lt;/sum&gt;\n</code></pre> <p>In the example above, the sum element contains three other items. What gets evaluated is written algebraically as:</p> \\[ 3.14159 + \\mathtt{qbar} + \\big( 0.125 \\cdot \\mathtt{wingarea} \\big) \\] <p>A full function definition, such as is used in the aerodynamics section of a configuration file includes the function element, and other elements. It should be noted that there can be only one non-optional (non-documentation) element \u2014 that is, one operation element \u2014 in the top-level function definition. The  element cannot have more than one immediate child operation, <code>property</code>, <code>table</code>, or <code>value</code> element. Almost always, the first operation within the function element will be a product or sum. For example: <pre><code>&lt;function name=\"aero/moment/roll_moment_due_to_yaw_rate\"&gt;\n&lt;description&gt; Roll moment due to yaw rate &lt;/description&gt;\n&lt;product&gt;\n&lt;property&gt; aero/qbar-area &lt;/property&gt;\n&lt;property&gt; metrics/bw-ft &lt;/property&gt;\n&lt;property&gt; velocities/r-aero-rad_sec &lt;/property&gt;\n&lt;property&gt; aero/bi2vel &lt;/property&gt;\n&lt;table&gt;\n&lt;independentVar&gt; aero/alpha-rad &lt;/independentVar&gt;\n&lt;tableData&gt;\n0.000 0.08\n            0.094 0.19\n            ...   ...\n         &lt;/tableData&gt;\n&lt;/table&gt;\n&lt;/product&gt;\n&lt;/function&gt;\n</code></pre> <p>The \u201clowest level\u201d in a function definition is always a value or a property, which cannot itself contain another element. As shown, operations can contain values, properties, tables, or other operations.</p> <p>Some operations take only a single argument. That argument, however, can be an operation (such as sum) which can contain other items. The point to keep in mind is any such contained operation evaluates to a single value \u2014 which is just what the trigonometric functions require (except atan2 , which takes two arguments).</p> <p>Finally, within a function definition, there are some shorthand aliases that can be used for brevity in place of the standard element tags. Properties, values, and tables are normally referred to with the tags, <code>&lt;property&gt;</code>, <code>&lt;value&gt;</code>, and <code>&lt;table&gt;</code>. Within a function definition only, those elements can be referred to with the tags, <code>&lt;p&gt;</code>, <code>&lt;v&gt;</code>, and <code>&lt;t&gt;</code>. Thus, the previous example could be written to look like this:</p> <pre><code>&lt;function name=\"aero/moment/roll_moment_due_to_yaw_rate\"&gt;\n&lt;description&gt;Roll moment due to yaw rate&lt;/description&gt;\n&lt;product&gt;\n&lt;p&gt; aero/qbar-area &lt;/p&gt;\n&lt;p&gt; metrics/bw-ft &lt;/p&gt;\n&lt;p&gt; aero/bi2vel &lt;/p&gt;\n&lt;p&gt; velocities/r-aero-rad_sec &lt;/p&gt;\n&lt;t&gt;\n&lt;independentVar&gt; aero/alpha-rad &lt;/independentVar&gt;\n&lt;tableData&gt;\n0.000 0.08\n            0.094 0.19\n            ...   ...\n         &lt;/tableData&gt;\n&lt;/t&gt;\n&lt;/product&gt;\n&lt;/function&gt;\n</code></pre> <p>An example of tabular functions used in aerodynamic modeling is given by ground-effect factors affecting lift and drag. An explanation of the ground effect is given in the figure below.</p> <p> </p>      Explanation of ground effect.    <p>To see how the ground effect can be modelled in JSBSim one can look at the Cessna 172 Skyhawk model. This is implemented in the file: <code>&lt;JSBSim-root-dir&gt;/aircraft/c172p/c172p.xml</code>. In the <code>&lt;aerodynamics/&gt;</code> block of this XML file two non-dimensional factors are modeled, \\(K_{C_D,\\mathrm{ge}}\\) and \\(K_{C_L,\\mathrm{ge}}\\), which are functions of the non-dimensional height above the ground and are to be thought of as multipliers of lift and drag, respectively. These factors are defined as follows:</p> <pre><code>&lt;function name=\"aero/function/kCDge\"&gt;\n&lt;description&gt;Change in drag due to ground effect&lt;/description&gt;\n&lt;product&gt;\n&lt;value&gt;1.0&lt;/value&gt;\n&lt;table&gt;\n&lt;independentVar&gt; aero/h_b-mac-ft &lt;/independentVar&gt;\n&lt;tableData&gt;\n0.0000 0.4800\n            0.1000 0.5150\n            0.1500 0.6290\n            0.2000 0.7090\n            0.3000 0.8150\n            0.4000 0.8820\n            0.5000 0.9280\n            0.6000 0.9620\n            0.7000 0.9880\n            0.8000 1.0000\n            0.9000 1.0000\n            1.0000 1.0000\n            1.1000 1.0000\n         &lt;/tableData&gt;\n&lt;/table&gt;\n&lt;/product&gt;\n&lt;/function&gt;\n\n&lt;function name=\"aero/function/kCLge\"&gt;\n&lt;description&gt;Change in lift due to ground effect&lt;/description&gt;\n&lt;product&gt;\n&lt;value&gt;1.0&lt;/value&gt;\n&lt;table&gt;\n&lt;independentVar&gt; aero/h_b-mac-ft &lt;/independentVar&gt;\n&lt;tableData&gt;\n0.0000 1.2030\n            0.1000 1.1270\n            0.1500 1.0900\n            0.2000 1.0730\n            0.3000 1.0460\n            0.4000 1.0550\n            0.5000 1.0190\n            0.6000 1.0130\n            0.7000 1.0080\n            0.8000 1.0060\n            0.9000 1.0030\n            1.0000 1.0020\n            1.1000 1.0000\n         &lt;/tableData&gt;\n&lt;/table&gt;\n&lt;/product&gt;\n&lt;/function&gt;\n</code></pre> <p>The tabular functions <code>aero/function/kCDge and aero/function/kCLge</code>, representing the factors \\(K_{C_D,\\mathrm{ge}}\\) and \\(K_{C_L,\\mathrm{ge}}\\), are plotted in the figure below against the non-dimensional ground altitude \\(h/(b/2)\\). The ground-effect is seen when the aircraft altitude above the ground is less than the wing semi-span \\(b/2\\). For higher altitudes each of these two factors assume value 1.</p> <p> </p> <p>     Plotted functions of non-dimensional ground altitude \\(h/(b/2)\\), defining the properties named 'aero/function/kCLge' and 'aero/function/kCDge' in the aerodynamic model of c172p.   </p>"},{"location":"user/concepts/math/#tables","title":"Tables","text":"<p>One, two, or three dimensional lookup tables can be defined in JSBSim for use in aerodynamics and function definitions. For a single \"vector\" lookup table, the format is as follows:</p> <pre><code>&lt;table name=\"property_name_0\"&gt;\n&lt;independentVar lookup=\"row\"&gt; property_name_1 &lt;/independentVar&gt;\n&lt;tableData&gt;\nkey_1  value_1\n      key_2  value_2\n      ...    ...\n      key_n  value_n\n   &lt;/tableData&gt;\n&lt;/table&gt;\n</code></pre> <p>The <code>lookup=\"row\"</code> attribute in the <code>&lt;independentVar/&gt;</code> element is optional in this case; it is assumed that the <code>independentVar</code> is a row variable. A real example is as shown here:</p> <pre><code>&lt;table&gt;\n&lt;independentVar lookup=\"row\"&gt; aero/alpha-rad &lt;/independentVar&gt;\n&lt;tableData&gt;\n-1.57  1.500\n      -0.26  0.033\n       0.00  0.025\n       0.26  0.033\n       1.57  1.500\n   &lt;/tableData&gt;\n&lt;/table&gt;\n</code></pre> <p>The first column in the data table represents the lookup index (or breakpoints, or keys). In this case, the lookup index is <code>aero/alpha-rad</code> (angle of attack in radians). If <code>aero/alpha-rad</code> is \\(0.26\\) radians, the value returned from the lookup table would be \\(0.033\\).</p> <p>The definition for a 2D table, is as follows:</p> <pre><code>&lt;table name=\"property_name_0\"&gt;\n&lt;independentVar lookup=\"row\"&gt;    property_name_1 &lt;/independentVar&gt;\n&lt;independentVar lookup=\"column\"&gt; property_name_2 &lt;/independentVar&gt;\n&lt;tableData&gt;\n{col_1_key   col_2_key   ...  col_n_key }\n      {row_1_key} {col_1_data  col_2_data  ...  col_n_data}\n      {row_2_key} {...         ...         ...  ...       }\n      {   ...   } {...         ...         ...  ...       }\n      {row_n_key} {...         ...         ...  ...       }\n   &lt;/tableData&gt;\n&lt;/table&gt;\n</code></pre> <p>The data is in a gridded format. A real example is as shown below. Alpha in radians is the row lookup (alpha breakpoints are arranged in the first column) and flap position in degrees is split up in columns for deflections of 0, 10, 20, and 30 degrees):</p> <pre><code>&lt;table&gt;\n&lt;independentVar lookup=\"row\"&gt;    aero/alpha-rad   &lt;/independentVar&gt;\n&lt;independentVar lookup=\"column\"&gt; fcs/flap-pos-deg &lt;/independentVar&gt;\n&lt;tableData&gt;\n0.0          10.0        20.0       30.0\n     -0.0523599  8.96747e-05  0.00231942  0.0059252  0.00835082\n     -0.0349066  0.000313268  0.00567451  0.0108461  0.0140545\n     -0.0174533  0.00201318   0.0105059   0.0172432  0.0212346\n      0.0        0.0051894    0.0168137   0.0251167  0.0298909\n      0.0174533  0.00993967   0.0247521   0.0346492  0.0402205\n      0.0349066  0.0162201    0.0342207   0.0457119  0.0520802\n      0.0523599  0.0240308    0.0452195   0.0583047  0.0654701\n      0.0698132  0.0333717    0.0577485   0.0724278  0.0803902\n      0.0872664  0.0442427    0.0718077   0.088081   0.0968405\n  &lt;/tableData&gt;\n&lt;/table&gt;\n</code></pre> <p>The definition for a 3D table in a coefficient would be (for example):</p> <pre><code>&lt;table name=\"property_name_0\"&gt;\n&lt;independentVar lookup=\"row\"&gt;    property_name_1 &lt;/independentVar&gt;\n&lt;independentVar lookup=\"column\"&gt; property_name_2 &lt;/independentVar&gt;\n&lt;independentVar lookup=\"table\"&gt;  property_name_3 &lt;/independentVar&gt;\n&lt;tableData  breakpoint=\"table_1_key\"&gt;\n{col_1_key   col_2_key   ...  col_n_key }\n      {row_1_key} {col_1_data  col_2_data  ...  col_n_data}\n      {row_2_key} {...         ...         ...  ...       }\n      {   ...   } {...         ...         ...  ...       }\n      {row_n_key} {...         ...         ...  ...       }\n   &lt;/tableData&gt;\n&lt;tableData  breakpoint=\"table_2_key\"&gt;\n{col_1_key   col_2_key   ...  col_n_key }\n      {row_1_key} {col_1_data  col_2_data  ...  col_n_data}\n      {row_2_key} {...         ...         ...  ...       }\n      {   ...   } {...         ...         ...  ...       }\n      {row_n_key} {...         ...         ...  ...       }\n   &lt;/tableData&gt;\n...\n   &lt;tableData  breakpoint=\"table_n_key\"&gt;\n{col_1_key   col_2_key   ...  col_n_key }\n      {row_1_key} {col_1_data  col_2_data  ...  col_n_data}\n      {row_2_key} {...         ...         ...  ...       }\n      {   ...   } {...         ...         ...  ...       }\n      {row_n_key} {...         ...         ...  ...       }\n   &lt;/tableData&gt;   &lt;/table&gt;\n</code></pre> <p>Note the breakpoint attribute in the tableData element, above. Here\u2019s an example:</p> <pre><code>&lt;table&gt;\n&lt;independentVar lookup=\"row\"&gt;    fcs/row-value    &lt;/independentVar&gt;\n&lt;independentVar lookup=\"column\"&gt; fcs/column-value &lt;/independentVar&gt;\n&lt;independentVar lookup=\"table\"&gt;  fcs/table-value  &lt;/independentVar&gt;\n&lt;tableData breakPoint=\"-1.0\"&gt;\n-1.0    1.0\n      0.0  1.0000  2.0000\n      1.0  3.0000  4.0000\n   &lt;/tableData&gt;\n&lt;tableData breakPoint=\"0.0000\"&gt;\n0.0     10.0\n      2.0  1.0000  2.0000\n      3.0  3.0000  4.0000\n   &lt;/tableData&gt;\n&lt;tableData breakPoint=\"1.0\"&gt;\n0.0     10.0    20.0\n       2.0  1.0000  2.0000  3.0000\n       3.0  4.0000  5.0000  6.0000\n      10.0  7.0000  8.0000  9.0000\n   &lt;/tableData&gt;\n&lt;/table&gt;\n</code></pre> <p>Note that table values are interpolated linearly, and no extrapolation is done at the table limits \u2014 the highest value a table will return is the highest value that is defined.</p>"},{"location":"user/concepts/math/#interpolate-1d","title":"Interpolate 1D","text":"<p>Some lookup tables in simulation - particularly for aerodynamic data - can be four, five, six, or even more dimensional.  Interpolate1d returns the result from a 1-dimensional interpolation of the supplied values, with the value of the first immediate child element representing the lookup value into the table, and the following pairs of values representing the independent and dependent values. The first provided child element is expected to be a property. The interpolation does not extrapolate, but holds the highest value if the provided lookup value goes outside of the provided range. The format is as follows:</p> <pre><code>&lt;interpolate1d&gt;\n{property, value, table, function}\n  {property, value, table, function} {property, value, table, function}\n  ...\n&lt;/interpolate1d&gt;\n</code></pre> <p>Example: If mach is 0.4, the interpolation will return 0.375. If mach is 1.5, the interpolation will return 0.60.</p> <pre><code>&lt;interpolate1d&gt;\n&lt;p&gt; velocities/mach &lt;/p&gt;\n&lt;v&gt; 0.00 &lt;/v&gt;  &lt;v&gt; 0.25 &lt;/v&gt;\n&lt;v&gt; 0.80 &lt;/v&gt;  &lt;v&gt; 0.50 &lt;/v&gt;\n&lt;v&gt; 0.90 &lt;/v&gt;  &lt;v&gt; 0.60 &lt;/v&gt;\n&lt;/interpolate1d&gt;\n</code></pre> <p>The above example is very simplistic. A more involved example would use a function in any argument (except the first). That means that the breakpoint vector can be variable - which would probably not be common - but more importantly the values in the lookup vector (second column) could be function table elements of 1, 2, or 3 dimensions. The arguments could even be nested interpolate1d elements. For example:</p> <pre><code>&lt;function name=\"whatever\"&gt;\n&lt;interpolate1d&gt;\n&lt;p&gt; velocities/mach &lt;/p&gt;\n&lt;v&gt; 0.00 &lt;/v&gt;  &lt;table&gt; ... table definition ... &lt;/table&gt;\n&lt;v&gt; 0.80 &lt;/v&gt;  &lt;table&gt; ... table definition ... &lt;/table&gt;\n&lt;v&gt; 0.90 &lt;/v&gt;  &lt;table&gt; ... table definition ... &lt;/table&gt;\n&lt;/interpolate1d&gt;\n&lt;/function&gt;\n</code></pre> <p>Carrying this further:</p> <pre><code>&lt;function name=\"bigWhatever1\"&gt;\n&lt;interpolate1d&gt;\n&lt;p&gt; aero/qbar-psf &lt;/p&gt;\n&lt;v&gt; 0 &lt;/v&gt;  &lt;interpolate1d&gt;\n&lt;p&gt; velocities/mach &lt;/p&gt;\n&lt;v&gt; 0.00 &lt;/v&gt;  &lt;table&gt; ... table 1 definition ... &lt;/table&gt;\n&lt;v&gt; 0.80 &lt;/v&gt;  &lt;table&gt; ... table 2 definition ... &lt;/table&gt;\n&lt;v&gt; 0.90 &lt;/v&gt;  &lt;table&gt; ... table 3 definition ... &lt;/table&gt;\n&lt;/interpolate1d&gt;\n&lt;v&gt; 65 &lt;/v&gt; &lt;interpolate1d&gt;\n&lt;p&gt; velocities/mach &lt;/p&gt;\n&lt;v&gt; 0.00 &lt;/v&gt;  &lt;table&gt; ... table 1 definition ... &lt;/table&gt;\n&lt;v&gt; 0.80 &lt;/v&gt;  &lt;table&gt; ... table 2 definition ... &lt;/table&gt;\n&lt;v&gt; 0.90 &lt;/v&gt;  &lt;table&gt; ... table 3 definition ... &lt;/table&gt;\n&lt;/interpolate1d&gt;\n&lt;v&gt; 90 &lt;/v&gt; &lt;interpolate1d&gt;\n&lt;p&gt; velocities/mach &lt;/p&gt;\n&lt;v&gt; 0.00 &lt;/v&gt;  &lt;table&gt; ... table 1 definition ... &lt;/table&gt;\n&lt;v&gt; 0.80 &lt;/v&gt;  &lt;table&gt; ... table 2 definition ... &lt;/table&gt;\n&lt;v&gt; 0.90 &lt;/v&gt;  &lt;table&gt; ... table 3 definition ... &lt;/table&gt;\n&lt;/interpolate1d&gt;\n&lt;/interpolate1d&gt;\n&lt;/function&gt;\n</code></pre> <p>The above effectively gives a five dimensional lookup table. It would be big and messy, in practice, but there it is. :-)</p> <p>There is more, though. For very, very large aero databases there might be times when some aero coefficients do not need to be calculated. For instance, ground effects aero coefficients only need to be calculated close to the ground. Why waste CPU cycles when the ground effects do not contribute to the aero forces and moments? We can employ the <code>ifthen</code> element to bypass expensive computations. The <code>ifthen</code> element works as follows:</p> <p>If the value of the first immediate child element is 1, then the value of the second immediate child element is returned, otherwise the value of the third child element is returned.</p> <p>If the value of the first immediate child element is 1, then the value of the second immediate child element is returned, otherwise the value of the third child element is returned.</p> <pre><code>&lt;ifthen&gt;\n{property, value, table, or other function element}\n  {property, value, table, or other function element}\n  {property, value, table, or other function element}\n&lt;/ifthen&gt;\n</code></pre> <p>Example: if flight-mode is greater than 2, then a value of 0.00 is returned, otherwise the value of the property control/pitch-lag is returned.</p> <pre><code>&lt;ifthen&gt;\n&lt;gt&gt; &lt;p&gt; executive/flight-mode &lt;/p&gt; &lt;v&gt; 2 &lt;/v&gt; &lt;/gt&gt;\n&lt;v&gt; 0.00 &lt;/v&gt;\n&lt;p&gt; control/pitch-lag &lt;/p&gt;\n&lt;/ifthen&gt;\n</code></pre> <p>In our case, we could write the 5-dimensional table lookup as follows, returning a zero unless the gear is down:</p> <pre><code>&lt;function name=\"propertyname\"&gt;\n&lt;ifthen&gt;\n&lt;lt&gt; &lt;p&gt; position/altitudeMSL &lt;/p&gt; &lt;v&gt; 90 &lt;/v&gt; &lt;/lt&gt;\n&lt;interpolate1d&gt;\n&lt;p&gt; aero/qbar-psf &lt;/p&gt;\n&lt;v&gt; 0 &lt;/v&gt;  &lt;interpolate1d&gt;\n&lt;p&gt; velocities/mach &lt;/p&gt;\n&lt;v&gt; 0.00 &lt;/v&gt;  &lt;table&gt; ... table 1 definition ... &lt;/table&gt;\n&lt;v&gt; 0.80 &lt;/v&gt;  &lt;table&gt; ... table 2 definition ... &lt;/table&gt;\n&lt;v&gt; 0.90 &lt;/v&gt;  &lt;table&gt; ... table 3 definition ... &lt;/table&gt;\n&lt;/interpolate1d&gt;\n&lt;v&gt; 65 &lt;/v&gt; &lt;interpolate1d&gt;\n&lt;p&gt; velocities/mach &lt;/p&gt;\n&lt;v&gt; 0.00 &lt;/v&gt;  &lt;table&gt; ... table 1 definition ... &lt;/table&gt;\n&lt;v&gt; 0.80 &lt;/v&gt;  &lt;table&gt; ... table 2 definition ... &lt;/table&gt;\n&lt;v&gt; 0.90 &lt;/v&gt;  &lt;table&gt; ... table 3 definition ... &lt;/table&gt;\n&lt;/interpolate1d&gt;\n&lt;v&gt; 90 &lt;/v&gt; &lt;interpolate1d&gt;\n&lt;p&gt; velocities/mach &lt;/p&gt;\n&lt;v&gt; 0.00 &lt;/v&gt;  &lt;table&gt; ... table 1 definition ... &lt;/table&gt;\n&lt;v&gt; 0.80 &lt;/v&gt;  &lt;table&gt; ... table 2 definition ... &lt;/table&gt;\n&lt;v&gt; 0.90 &lt;/v&gt;  &lt;table&gt; ... table 3 definition ... &lt;/table&gt;\n&lt;/interpolate1d&gt;\n&lt;/interpolate1d&gt;\n&lt;v&gt; 0 &lt;/v&gt;\n&lt;/ifthen&gt;\n&lt;/function&gt;\n</code></pre> <p>The above example is non-sensical in a way, but the format is correct.  Performance-wise it is good because the tables do not get executed unless  absolutely needed in the lookup.</p>"},{"location":"user/concepts/properties/","title":"Properties","text":"<p>Simulation programs need to manage a large amount of state information. With especially large programs, the data management task can cause problems:</p> <ul> <li>Contributors find it harder and harder to master the number of interfaces necessary to make any useful additions to the program, so contributions slow down.</li> <li>Runtime configurability becomes increasingly difficult, with different modules using different mechanisms (environment variables, custom specification files, command-line options, etc.).</li> <li>The order of initialization of modules is complicated and brittle, since one module's initialization routines might need to set or retrieve state information from an uninitialized module.</li> <li>Extensibility through add-on scripts, specification files, etc. is limited to the state information that the program provides, and non-code-writing developers often have to wait too long for the developers to get around to adding a new variable.</li> </ul> <p>The Property Manager system provides a single interface for chosen program state information, and allows the creation of new, user-specified variables dynamically at run-time. The latter capability is especially important for the JSBSim control system model because the various control system components (PID controllers, switches, summer, gains, etc.) that make up the control law definition for an aircraft exist only in a configuration file. At runtime \u2014 after parsing the component definitions \u2014 the components are instantiated, and the property manager creates a property to store the output value of each component.</p> <p>Properties themselves are like global variables with selectively limited visibility (read or read/write) that are categorized into a hierarchical, tree-like structure that is similar to the structure of a Unix file system. The structure of the property tree includes a root node, sub nodes, (like subdirectories) and end-nodes (properties). Similar to a Unix file system, properties can be referenced relative to the current node, or to the root node. Nodes can be grafted onto other nodes similar to symbolically linking files or directories to other files or directories in a file system. Properties are used throughout JSBSim and FlightGear to refer to specific parameters in program code. Properties can be assigned from the command line, from specification files and scripts, and even via a socket interface. Property names look like: <code>position/h-sl-ft</code>, and <code>aero/qbar-psf</code>.</p> <p>To illustrate the power of using properties and configuration files, consider the case of a high-performance jet aircraft model. Assume for a moment that a new switch has been added to the control panel for the example aircraft that allows the pilot to override pitch limits in the FCS. For FlightGear, the instrument panel is defined in a configuration file, and the switch is defined there for visual display. A property name is also assigned to the switch definition. Within the flight control portion of the JSBSim aircraft specification file, that same property name assigned to the pitch override switch in the instrument panel definition file can be used to channel the control laws through the desired path as a function of the switch position. No code needs to be touched.</p> <p>Specific simulation parameters are available both from within JSBSim and in configuration file specifications via properties. As mentioned earlier, \u201cproperties\u201d are the term we use to describe parameters that we can access or set from within a configuration file, or on the command line.</p> <p>Many properties are standard properties \u2014 i.e. those properties that are always present for all vehicles. The aerodynamic coefficients, engines, thrusters, and flight control/autopilot models will also have dynamically defined properties. This is because the whole set of aerodynamic coefficients, engines, etc. will not be known until after the relevant configuration file for an aircraft is read. One must know the convention used to name the properties for these parameters in order to access them. As an example, the flight control system for the X-15 model features the following components, among others:</p> <pre><code>&lt;flight_control name=\"X-15\"&gt;\n&lt;channel name=\"Pitch\"&gt;\n&lt;summer name=\"fcs/pitch-trim-sum\"&gt;\n&lt;input&gt; fcs/elevator-cmd-norm &lt;/input&gt;\n&lt;input&gt; fcs/pitch-trim-cmd-norm &lt;/input&gt;\n&lt;clipto&gt;\n&lt;min&gt; -1 &lt;/min&gt;\n&lt;max&gt;  1 &lt;/max&gt;\n&lt;/clipto&gt;\n&lt;/summer&gt;\n&lt;aerosurface_scale name=\"fcs/pitch-command-scale\"&gt;\n&lt;input&gt; fcs/pitch-trim-sum &lt;/input&gt;\n&lt;range&gt;\n&lt;min&gt; -50 &lt;/min&gt;\n&lt;max&gt;  50 &lt;/max&gt;\n&lt;/range&gt;\n&lt;/aerosurface_scale&gt;\n&lt;pure_gain name=\"fcs/pitch-gain-1\"&gt;\n&lt;input&gt; fcs/pitch-command-scale &lt;/input&gt;\n&lt;gain&gt; -0.36 &lt;/gain&gt;\n&lt;/pure_gain&gt;\n&lt;/channel&gt;\n&lt;/flight_control&gt;\n</code></pre> <p>The first component above (<code>fcs/pitch-trim-sum</code>) takes input from two places, the known static properties, <code>fcs/elevator-cmd-norm</code> and <code>fcs/pitch-trim-cmd-norm</code>. The next component takes as input the output from the first component. The input property listed for the second component is <code>fcs/pitch-trim-sum</code>. Continuing with the above case shows that the last component, <code>fcs/pitch-gain-1</code>, takes as input the output from the preceding component, <code>fcs/pitch-command-scale</code>, which is given the property name, <code>fcs/pitch-command-scale</code>.</p> <p>So, now we have a way to access many parameters inside JSBSim. We know how the FCS is assembled in JSBSim. The same components used in the FCS are also available to build an autopilot, or other system.</p>"},{"location":"user/concepts/simulation/","title":"Simulation","text":"<p>While the JSBSim user does not need to know some of the finer details of the flight simulator operation, it can be helpful to understand basically how JSBSim works. Some of the most important concepts are described in this section.</p> <ul> <li> <p>Frames of reference are used to describe the placement and location of various items in a vehicle model.</p> </li> <li> <p>There is flexibility in how the units of measure can be specified when defining a vehicle model \u2013 both English and metric units are supported.</p> </li> <li> <p>The use of \u201cProperties\u201d permits JSBSim to be a generic simulator, providing a way to interface the various systems with parameters (or variables). Properties are used throughout the configuration files that describe aircraft and engine characteristics.</p> </li> <li> <p>Obviously, math plays a big part in modeling flight physics. JSBSim makes use of data tables, as flight dynamics characteristics are often stored in tables. Arbitrary algebraic functions can also be set up in JSBSim, allowing broad freedom for describing aerodynamic and flight control characteristics.</p> </li> <li> <p>Users have to have, at least a basic knowledge, of conventional forces and moments acting on an airplane in flight.</p> </li> <li> <p>The understanding of flight controls and of how system modelling can be achieved in JSBSim are the keys for successful and effective simulations.</p> </li> </ul>"},{"location":"user/concepts/units/","title":"Units","text":"<p>JSBSim uses English units for internal calculations almost exclusively. However, it is possible to input some parameters in the configuration file using different units. In fact, to avoid confusion, it is recommended that the unit always be specified. Units are specified using the <code>unit</code> attribute. For instance, the specification for the wingspan looks like this:</p> <pre><code>&lt;wingspan unit=\"FT\"&gt; 35.8 &lt;/wingspan&gt;\n</code></pre> <p>The above statement specifies a wingspan of 35.8 feet. The following statement specifying the wingspan in meters would result in the wingspan being converted to 35.8 feet as it was read in:</p> <pre><code>&lt;wingspan unit=\"M\"&gt; 10.91 &lt;/wingspan&gt;\n</code></pre> <p>The two statements for wingspan are effectively equivalent.</p> <p>The following units are currently supported in JSBSim:</p> <p>Length</p> <code>unit=</code> unit <code>FT</code> ft <code>IN</code> in <code>M</code> m <code>KM</code> km <p>Area</p> <code>unit=</code> unit <code>M2</code> m\u00b2 <code>FT2</code> ft\u00b2 <p>Volume</p> <code>unit=</code> unit <code>FT3</code> ft\u00b3 <code>CC</code> cm\u00b3 <code>M3</code> m\u00b3 <code>LTR</code> l <p>Mass and Weight</p> <code>unit=</code> unit <code>LBS</code> lbm <code>KG</code> kg <p>Moments of Inertia</p> <code>unit=</code> unit <code>SLUG*FT2</code> slug ft\u00b2 <code>KG*M2</code> kg m\u00b2 <p>Angles</p> <code>unit=</code> unit <code>RAD</code> rad <code>DEG</code> deg <p>Spring Force</p> <code>unit=</code> unit <code>N/M</code> N/m <code>LBS/FT</code> lb/ft <p>Damping Force</p> <code>unit=</code> unit <code>N/M/SEC</code> N/(m s) <code>LBS/FT/SEC</code> lb/(ft s) <p>Power</p> <code>unit=</code> unit <code>WATTS</code> W <code>HP</code> Hp <p>Force</p> <code>unit=</code> unit <code>LBS</code> lb <code>N</code> N <p>Velocity</p> <code>unit=</code> unit <code>KTS</code> kts <code>FT/SEC</code> ft/s <code>M/S</code> m/s <p>Torque</p> <code>unit=</code> unit <code>N*M</code> N m <code>FT*LBS</code> lb ft <p>Pressure</p> <code>unit=</code> unit <code>PSF</code> lb/ft\u00b2 <code>PSI</code> lb/in\u00b2 <code>ATM</code> atm <code>PA</code> N/m\u00b2 <code>INHG</code> in HG"}]}